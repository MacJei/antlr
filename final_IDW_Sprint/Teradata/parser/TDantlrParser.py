# Generated from TDantlr.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0220")
        buf.write("\u03fd\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\3\2\3\2\7\2\u0095\n\2")
        buf.write("\f\2\16\2\u0098\13\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\5\3\u00a1")
        buf.write("\n\3\3\4\5\4\u00a4\n\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5")
        buf.write("\5\5\u00ae\n\5\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6\u00c2\n\6\3\6\5\6")
        buf.write("\u00c5\n\6\3\6\3\6\5\6\u00c9\n\6\3\6\5\6\u00cc\n\6\3\6")
        buf.write("\5\6\u00cf\n\6\3\6\3\6\3\6\5\6\u00d4\n\6\3\6\5\6\u00d7")
        buf.write("\n\6\3\6\3\6\3\6\3\6\5\6\u00dd\n\6\3\6\3\6\3\6\3\6\5\6")
        buf.write("\u00e3\n\6\5\6\u00e5\n\6\3\6\3\6\3\6\3\6\6\6\u00eb\n\6")
        buf.write("\r\6\16\6\u00ec\7\6\u00ef\n\6\f\6\16\6\u00f2\13\6\3\7")
        buf.write("\3\7\3\b\3\b\3\b\3\b\7\b\u00fa\n\b\f\b\16\b\u00fd\13\b")
        buf.write("\5\b\u00ff\n\b\3\t\3\t\5\t\u0103\n\t\3\t\5\t\u0106\n\t")
        buf.write("\3\t\3\t\3\t\3\t\5\t\u010c\n\t\3\n\3\n\3\n\3\n\3\13\5")
        buf.write("\13\u0113\n\13\3\13\5\13\u0116\n\13\3\13\3\13\5\13\u011a")
        buf.write("\n\13\3\13\5\13\u011d\n\13\3\13\5\13\u0120\n\13\3\13\3")
        buf.write("\13\5\13\u0124\n\13\5\13\u0126\n\13\3\f\3\f\3\f\5\f\u012b")
        buf.write("\n\f\3\f\3\f\5\f\u012f\n\f\3\r\3\r\3\r\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\5\16\u0140")
        buf.write("\n\16\3\16\3\16\3\16\5\16\u0145\n\16\3\16\5\16\u0148\n")
        buf.write("\16\3\16\3\16\3\16\7\16\u014d\n\16\f\16\16\16\u0150\13")
        buf.write("\16\3\16\5\16\u0153\n\16\3\16\5\16\u0156\n\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\5\16\u0162\n")
        buf.write("\16\3\16\5\16\u0165\n\16\3\16\5\16\u0168\n\16\3\16\3\16")
        buf.write("\3\16\5\16\u016d\n\16\3\16\5\16\u0170\n\16\3\16\3\16\3")
        buf.write("\16\3\16\3\16\3\16\5\16\u0178\n\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\6\16\u017f\n\16\r\16\16\16\u0180\3\16\3\16\5\16")
        buf.write("\u0185\n\16\3\16\3\16\5\16\u0189\n\16\3\16\3\16\3\16\3")
        buf.write("\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\5\16\u019c\n\16\3\16\3\16\3\16\3\16\3")
        buf.write("\16\3\16\3\16\5\16\u01a5\n\16\3\16\3\16\3\16\3\16\5\16")
        buf.write("\u01ab\n\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\5")
        buf.write("\16\u01b5\n\16\3\16\3\16\5\16\u01b9\n\16\3\16\3\16\3\16")
        buf.write("\3\16\5\16\u01bf\n\16\3\16\3\16\3\16\3\16\5\16\u01c5\n")
        buf.write("\16\3\16\5\16\u01c8\n\16\3\16\3\16\3\16\3\16\7\16\u01ce")
        buf.write("\n\16\f\16\16\16\u01d1\13\16\3\17\3\17\3\17\7\17\u01d6")
        buf.write("\n\17\f\17\16\17\u01d9\13\17\3\20\3\20\3\20\3\20\3\21")
        buf.write("\3\21\3\21\3\21\3\22\3\22\3\22\3\22\5\22\u01e7\n\22\3")
        buf.write("\22\3\22\3\22\3\22\3\22\3\22\5\22\u01ef\n\22\3\22\3\22")
        buf.write("\3\22\3\22\5\22\u01f5\n\22\3\22\3\22\3\22\3\22\5\22\u01fb")
        buf.write("\n\22\5\22\u01fd\n\22\3\22\5\22\u0200\n\22\3\22\3\22\3")
        buf.write("\23\3\23\3\23\7\23\u0207\n\23\f\23\16\23\u020a\13\23\3")
        buf.write("\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\5\24\u0214\n\24")
        buf.write("\3\25\3\25\3\25\3\25\3\25\3\25\3\25\5\25\u021d\n\25\3")
        buf.write("\26\3\26\3\26\3\27\3\27\7\27\u0224\n\27\f\27\16\27\u0227")
        buf.write("\13\27\3\30\3\30\5\30\u022b\n\30\3\31\3\31\5\31\u022f")
        buf.write("\n\31\3\31\5\31\u0232\n\31\3\32\3\32\3\32\3\32\5\32\u0238")
        buf.write("\n\32\3\32\3\32\3\32\3\32\3\32\5\32\u023f\n\32\3\33\3")
        buf.write("\33\3\33\5\33\u0244\n\33\5\33\u0246\n\33\3\33\3\33\3\33")
        buf.write("\3\33\3\33\3\33\3\33\3\33\3\33\3\33\5\33\u0252\n\33\3")
        buf.write("\34\3\34\3\34\3\34\3\34\5\34\u0259\n\34\3\34\3\34\3\34")
        buf.write("\5\34\u025e\n\34\7\34\u0260\n\34\f\34\16\34\u0263\13\34")
        buf.write("\5\34\u0265\n\34\3\35\3\35\3\35\3\36\3\36\5\36\u026c\n")
        buf.write("\36\3\37\3\37\3\37\3 \3 \3 \3!\3!\3!\7!\u0277\n!\f!\16")
        buf.write("!\u027a\13!\3\"\3\"\5\"\u027e\n\"\3#\3#\3#\7#\u0283\n")
        buf.write("#\f#\16#\u0286\13#\3$\3$\5$\u028a\n$\3$\3$\3$\3$\5$\u0290")
        buf.write("\n$\3$\3$\5$\u0294\n$\3$\3$\3$\3$\5$\u029a\n$\3$\3$\5")
        buf.write("$\u029e\n$\3$\3$\3$\3$\5$\u02a4\n$\3$\3$\5$\u02a8\n$\3")
        buf.write("$\3$\3$\3$\5$\u02ae\n$\5$\u02b0\n$\3%\3%\3%\5%\u02b5\n")
        buf.write("%\3&\3&\3&\3\'\3\'\5\'\u02bc\n\'\3\'\3\'\5\'\u02c0\n\'")
        buf.write("\3\'\5\'\u02c3\n\'\3\'\5\'\u02c6\n\'\3\'\5\'\u02c9\n\'")
        buf.write("\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u02d1\n\'\3\'\3\'\5\'\u02d5")
        buf.write("\n\'\3\'\5\'\u02d8\n\'\3\'\5\'\u02db\n\'\3\'\3\'\5\'\u02df")
        buf.write("\n\'\3\'\3\'\5\'\u02e3\n\'\3\'\3\'\3\'\3\'\5\'\u02e9\n")
        buf.write("\'\3(\3(\5(\u02ed\n(\3(\3(\3(\3(\3(\3(\3(\5(\u02f6\n(")
        buf.write("\5(\u02f8\n(\3)\3)\3)\5)\u02fd\n)\3)\5)\u0300\n)\3)\3")
        buf.write(")\5)\u0304\n)\3*\3*\3*\3*\3*\3*\5*\u030c\n*\3*\3*\3*\5")
        buf.write("*\u0311\n*\3*\3*\3*\3*\3*\5*\u0318\n*\3*\3*\3*\3*\3*\3")
        buf.write("*\3*\3*\5*\u0322\n*\3+\3+\3,\3,\5,\u0328\n,\3,\3,\3,\3")
        buf.write(",\3,\3,\5,\u0330\n,\3,\5,\u0333\n,\3-\3-\5-\u0337\n-\3")
        buf.write("-\5-\u033a\n-\3.\3.\3.\5.\u033f\n.\3.\5.\u0342\n.\3.\5")
        buf.write(".\u0345\n.\5.\u0347\n.\3.\5.\u034a\n.\3.\5.\u034d\n.\3")
        buf.write("/\3/\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\61\3\61\3\61")
        buf.write("\3\61\3\61\3\61\5\61\u035e\n\61\3\61\5\61\u0361\n\61\3")
        buf.write("\61\5\61\u0364\n\61\3\61\5\61\u0367\n\61\3\61\3\61\3\61")
        buf.write("\3\61\5\61\u036d\n\61\3\62\3\62\3\63\3\63\3\63\3\63\3")
        buf.write("\63\3\63\3\63\3\63\3\63\3\63\5\63\u037b\n\63\3\63\3\63")
        buf.write("\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3\63\5\63\u0387\n")
        buf.write("\63\3\63\3\63\3\63\3\63\3\63\5\63\u038e\n\63\3\64\3\64")
        buf.write("\3\65\3\65\3\65\7\65\u0395\n\65\f\65\16\65\u0398\13\65")
        buf.write("\3\66\3\66\3\66\3\66\3\66\3\66\5\66\u03a0\n\66\3\67\3")
        buf.write("\67\38\38\58\u03a6\n8\38\38\58\u03aa\n8\38\38\58\u03ae")
        buf.write("\n8\38\38\58\u03b2\n8\58\u03b4\n8\39\39\3:\3:\3;\3;\3")
        buf.write("<\3<\3=\5=\u03bf\n=\3=\3=\3>\5>\u03c4\n>\3>\3>\3?\5?\u03c9")
        buf.write("\n?\3?\3?\3@\3@\3A\3A\3A\5A\u03d2\nA\3A\3A\3B\3B\3B\5")
        buf.write("B\u03d9\nB\3B\3B\3B\3B\5B\u03df\nB\3B\5B\u03e2\nB\3C\3")
        buf.write("C\3D\3D\3D\6D\u03e9\nD\rD\16D\u03ea\3D\5D\u03ee\nD\3E")
        buf.write("\3E\3F\3F\3F\5F\u03f5\nF\3G\3G\3H\3H\3I\3I\3I\2\4\n\32")
        buf.write("J\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082")
        buf.write("\u0084\u0086\u0088\u008a\u008c\u008e\u0090\2\32\4\2\u0139")
        buf.write("\u0139\u013f\u013f\4\2ii\u00f4\u00f4\4\2\u0093\u0093\u00d6")
        buf.write("\u00d6\4\2RR\u0129\u0129\4\2\u00ec\u00ec\u0122\u0122\3")
        buf.write("\2\u0218\u0219\5\2\u00c2\u00c2\u00f3\u00f4\u014f\u014f")
        buf.write("\5\2\7\7))\u01b3\u01b3\3\2\n\13\4\2\t\t\16\17\4\2\b\b")
        buf.write("\24\32\4\2{{\u0132\u0132\n\2TT\u008a\u008a\u00a1\u00a1")
        buf.write("\u00a4\u00a4\u00a6\u00a6\u00aa\u00aa\u0133\u0133\u01a0")
        buf.write("\u01a0\b\2TT\u008a\u008a\u00a1\u00a1\u00a6\u00a6\u0133")
        buf.write("\u0133\u01a0\u01a0\3\2\u01d2\u01d3\5\2//\u00eb\u00eb\u015b")
        buf.write("\u015b\4\2\u00e9\u00e9\u00ef\u00ef\4\2\u00ca\u00ca\u00d0")
        buf.write("\u00d0\4\2\u0110\u0110\u0116\u0116\4\2\n\f\u00d2\u00d2")
        buf.write("\5\2\7\7\u0217\u0217\u021c\u021c\24\2||\u0098\u0098\u009a")
        buf.write("\u009a\u009e\u009e\u00ac\u00ac\u00b2\u00b2\u00ed\u00ed")
        buf.write("\u00f0\u00f0\u00fb\u00fb\u0100\u0101\u010b\u010b\u0111")
        buf.write("\u0111\u0140\u0141\u0146\u0146\u014d\u014d\u017b\u017b")
        buf.write("\u01ae\u01ae\u01c5\u01c5K\2\36\36\"\"$$\'(,,..\61\64\67")
        buf.write("\679:<@CCHHJKPPVV[[aafgjjmnppstvvyy\177\177\u0085\u0085")
        buf.write("\u008b\u008b\u008e\u008e\u0098\u009a\u009f\u009f\u00ab")
        buf.write("\u00ab\u00b0\u00b1\u00b7\u00b7\u00be\u00be\u00c4\u00c5")
        buf.write("\u00ce\u00ce\u00d4\u00d5\u00e0\u00e0\u00e4\u00e4\u00e6")
        buf.write("\u00e6\u00ea\u00eb\u00f7\u00f7\u00fc\u00fc\u010b\u010b")
        buf.write("\u0113\u0113\u0117\u0117\u011b\u011c\u0128\u0128\u012f")
        buf.write("\u012f\u0135\u0135\u013d\u013d\u0141\u0141\u0145\u0145")
        buf.write("\u0147\u0147\u014c\u014c\u0153\u0153\u0158\u0159\u015b")
        buf.write("\u015b\u015e\u015f\u0165\u0165\u0169\u0169\u016d\u016f")
        buf.write("\u0175\u0175\u017e\u017e\u0180\u0180\u0187\u0188\u018f")
        buf.write("\u0191\u01a6\u01a6\u01af\u01b1\u01bd\u01bd\u01cd\u01d0")
        buf.write("\u01d4\u01d7\u01db\u0216\22\2\36\36\"\"++\60\60\64\64")
        buf.write("<<CCVVXXZZ\u0096\u0096\u00d5\u00d5\u011b\u011b\u016e\u016e")
        buf.write("\u01be\u01be\u01d4\u01da\2\u0487\2\u0092\3\2\2\2\4\u00a0")
        buf.write("\3\2\2\2\6\u00a3\3\2\2\2\b\u00a7\3\2\2\2\n\u00b4\3\2\2")
        buf.write("\2\f\u00f3\3\2\2\2\16\u00fe\3\2\2\2\20\u010b\3\2\2\2\22")
        buf.write("\u010d\3\2\2\2\24\u0125\3\2\2\2\26\u0127\3\2\2\2\30\u0130")
        buf.write("\3\2\2\2\32\u0188\3\2\2\2\34\u01d2\3\2\2\2\36\u01da\3")
        buf.write("\2\2\2 \u01de\3\2\2\2\"\u01e2\3\2\2\2$\u0203\3\2\2\2&")
        buf.write("\u0213\3\2\2\2(\u021c\3\2\2\2*\u021e\3\2\2\2,\u0221\3")
        buf.write("\2\2\2.\u022a\3\2\2\2\60\u022c\3\2\2\2\62\u0233\3\2\2")
        buf.write("\2\64\u0251\3\2\2\2\66\u0253\3\2\2\28\u0266\3\2\2\2:\u026b")
        buf.write("\3\2\2\2<\u026d\3\2\2\2>\u0270\3\2\2\2@\u0273\3\2\2\2")
        buf.write("B\u027d\3\2\2\2D\u027f\3\2\2\2F\u02af\3\2\2\2H\u02b4\3")
        buf.write("\2\2\2J\u02b6\3\2\2\2L\u02e8\3\2\2\2N\u02ea\3\2\2\2P\u02f9")
        buf.write("\3\2\2\2R\u0321\3\2\2\2T\u0323\3\2\2\2V\u0325\3\2\2\2")
        buf.write("X\u0334\3\2\2\2Z\u0346\3\2\2\2\\\u034e\3\2\2\2^\u0350")
        buf.write("\3\2\2\2`\u0357\3\2\2\2b\u036e\3\2\2\2d\u038d\3\2\2\2")
        buf.write("f\u038f\3\2\2\2h\u0391\3\2\2\2j\u039f\3\2\2\2l\u03a1\3")
        buf.write("\2\2\2n\u03b3\3\2\2\2p\u03b5\3\2\2\2r\u03b7\3\2\2\2t\u03b9")
        buf.write("\3\2\2\2v\u03bb\3\2\2\2x\u03be\3\2\2\2z\u03c3\3\2\2\2")
        buf.write("|\u03c8\3\2\2\2~\u03cc\3\2\2\2\u0080\u03d1\3\2\2\2\u0082")
        buf.write("\u03e1\3\2\2\2\u0084\u03e3\3\2\2\2\u0086\u03e5\3\2\2\2")
        buf.write("\u0088\u03ef\3\2\2\2\u008a\u03f4\3\2\2\2\u008c\u03f6\3")
        buf.write("\2\2\2\u008e\u03f8\3\2\2\2\u0090\u03fa\3\2\2\2\u0092\u0096")
        buf.write("\5\4\3\2\u0093\u0095\7\3\2\2\u0094\u0093\3\2\2\2\u0095")
        buf.write("\u0098\3\2\2\2\u0096\u0094\3\2\2\2\u0096\u0097\3\2\2\2")
        buf.write("\u0097\u0099\3\2\2\2\u0098\u0096\3\2\2\2\u0099\u009a\7")
        buf.write("\2\2\3\u009a\3\3\2\2\2\u009b\u00a1\5\6\4\2\u009c\u00a1")
        buf.write("\5L\'\2\u009d\u00a1\5P)\2\u009e\u00a1\5R*\2\u009f\u00a1")
        buf.write("\5V,\2\u00a0\u009b\3\2\2\2\u00a0\u009c\3\2\2\2\u00a0\u009d")
        buf.write("\3\2\2\2\u00a0\u009e\3\2\2\2\u00a0\u009f\3\2\2\2\u00a1")
        buf.write("\5\3\2\2\2\u00a2\u00a4\5\b\5\2\u00a3\u00a2\3\2\2\2\u00a3")
        buf.write("\u00a4\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a6\5\n\6\2")
        buf.write("\u00a6\7\3\2\2\2\u00a7\u00a8\7\u018e\2\2\u00a8\u00ad\5")
        buf.write("r:\2\u00a9\u00aa\7\5\2\2\u00aa\u00ab\5h\65\2\u00ab\u00ac")
        buf.write("\7\6\2\2\u00ac\u00ae\3\2\2\2\u00ad\u00a9\3\2\2\2\u00ad")
        buf.write("\u00ae\3\2\2\2\u00ae\u00af\3\2\2\2\u00af\u00b0\7\u008d")
        buf.write("\2\2\u00b0\u00b1\7\5\2\2\u00b1\u00b2\5\n\6\2\u00b2\u00b3")
        buf.write("\7\6\2\2\u00b3\t\3\2\2\2\u00b4\u00b5\b\6\1\2\u00b5\u00c4")
        buf.write("\t\2\2\2\u00b6\u00c1\t\3\2\2\u00b7\u00b8\5\u0080A\2\u00b8")
        buf.write("\u00b9\7\4\2\2\u00b9\u00ba\7\t\2\2\u00ba\u00bb\7\4\2\2")
        buf.write("\u00bb\u00bc\7i\2\2\u00bc\u00c2\3\2\2\2\u00bd\u00be\5")
        buf.write("\u0082B\2\u00be\u00bf\7\4\2\2\u00bf\u00c0\7i\2\2\u00c0")
        buf.write("\u00c2\3\2\2\2\u00c1\u00b7\3\2\2\2\u00c1\u00bd\3\2\2\2")
        buf.write("\u00c1\u00c2\3\2\2\2\u00c2\u00c5\3\2\2\2\u00c3\u00c5\5")
        buf.write("\26\f\2\u00c4\u00b6\3\2\2\2\u00c4\u00c3\3\2\2\2\u00c4")
        buf.write("\u00c5\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6\u00c8\5\16\b")
        buf.write("\2\u00c7\u00c9\5*\26\2\u00c8\u00c7\3\2\2\2\u00c8\u00c9")
        buf.write("\3\2\2\2\u00c9\u00cb\3\2\2\2\u00ca\u00cc\5\66\34\2\u00cb")
        buf.write("\u00ca\3\2\2\2\u00cb\u00cc\3\2\2\2\u00cc\u00ce\3\2\2\2")
        buf.write("\u00cd\u00cf\58\35\2\u00ce\u00cd\3\2\2\2\u00ce\u00cf\3")
        buf.write("\2\2\2\u00cf\u00d3\3\2\2\2\u00d0\u00d1\7e\2\2\u00d1\u00d2")
        buf.write("\7\u0105\2\2\u00d2\u00d4\5@!\2\u00d3\u00d0\3\2\2\2\u00d3")
        buf.write("\u00d4\3\2\2\2\u00d4\u00d6\3\2\2\2\u00d5\u00d7\5:\36\2")
        buf.write("\u00d6\u00d5\3\2\2\2\u00d6\u00d7\3\2\2\2\u00d7\u00e4\3")
        buf.write("\2\2\2\u00d8\u00d9\7\u0138\2\2\u00d9\u00da\7\u0105\2\2")
        buf.write("\u00da\u00dc\5D#\2\u00db\u00dd\t\4\2\2\u00dc\u00db\3\2")
        buf.write("\2\2\u00dc\u00dd\3\2\2\2\u00dd\u00e2\3\2\2\2\u00de\u00df")
        buf.write("\7\u01c9\2\2\u00df\u00e3\7\u01a8\2\2\u00e0\u00e1\7\u01c9")
        buf.write("\2\2\u00e1\u00e3\7\u01c8\2\2\u00e2\u00de\3\2\2\2\u00e2")
        buf.write("\u00e0\3\2\2\2\u00e2\u00e3\3\2\2\2\u00e3\u00e5\3\2\2\2")
        buf.write("\u00e4\u00d8\3\2\2\2\u00e4\u00e5\3\2\2\2\u00e5\u00f0\3")
        buf.write("\2\2\2\u00e6\u00ea\f\3\2\2\u00e7\u00e8\5n8\2\u00e8\u00e9")
        buf.write("\5\n\6\2\u00e9\u00eb\3\2\2\2\u00ea\u00e7\3\2\2\2\u00eb")
        buf.write("\u00ec\3\2\2\2\u00ec\u00ea\3\2\2\2\u00ec\u00ed\3\2\2\2")
        buf.write("\u00ed\u00ef\3\2\2\2\u00ee\u00e6\3\2\2\2\u00ef\u00f2\3")
        buf.write("\2\2\2\u00f0\u00ee\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1\13")
        buf.write("\3\2\2\2\u00f2\u00f0\3\2\2\2\u00f3\u00f4\5\n\6\2\u00f4")
        buf.write("\r\3\2\2\2\u00f5\u00ff\7\t\2\2\u00f6\u00fb\5\20\t\2\u00f7")
        buf.write("\u00f8\7\7\2\2\u00f8\u00fa\5\20\t\2\u00f9\u00f7\3\2\2")
        buf.write("\2\u00fa\u00fd\3\2\2\2\u00fb\u00f9\3\2\2\2\u00fb\u00fc")
        buf.write("\3\2\2\2\u00fc\u00ff\3\2\2\2\u00fd\u00fb\3\2\2\2\u00fe")
        buf.write("\u00f5\3\2\2\2\u00fe\u00f6\3\2\2\2\u00ff\17\3\2\2\2\u0100")
        buf.write("\u0105\5\32\16\2\u0101\u0103\7\u008d\2\2\u0102\u0101\3")
        buf.write("\2\2\2\u0102\u0103\3\2\2\2\u0103\u0104\3\2\2\2\u0104\u0106")
        buf.write("\5t;\2\u0105\u0102\3\2\2\2\u0105\u0106\3\2\2\2\u0106\u010c")
        buf.write("\3\2\2\2\u0107\u0108\5\u0080A\2\u0108\u0109\7\4\2\2\u0109")
        buf.write("\u010a\7\t\2\2\u010a\u010c\3\2\2\2\u010b\u0100\3\2\2\2")
        buf.write("\u010b\u0107\3\2\2\2\u010c\21\3\2\2\2\u010d\u010e\7\5")
        buf.write("\2\2\u010e\u010f\5\u0086D\2\u010f\u0110\7\6\2\2\u0110")
        buf.write("\23\3\2\2\2\u0111\u0113\7\5\2\2\u0112\u0111\3\2\2\2\u0112")
        buf.write("\u0113\3\2\2\2\u0113\u0115\3\2\2\2\u0114\u0116\7\u00d2")
        buf.write("\2\2\u0115\u0114\3\2\2\2\u0115\u0116\3\2\2\2\u0116\u0117")
        buf.write("\3\2\2\2\u0117\u0119\t\5\2\2\u0118\u011a\7\6\2\2\u0119")
        buf.write("\u0118\3\2\2\2\u0119\u011a\3\2\2\2\u011a\u0126\3\2\2\2")
        buf.write("\u011b\u011d\7\5\2\2\u011c\u011b\3\2\2\2\u011c\u011d\3")
        buf.write("\2\2\2\u011d\u011f\3\2\2\2\u011e\u0120\7\u00d2\2\2\u011f")
        buf.write("\u011e\3\2\2\2\u011f\u0120\3\2\2\2\u0120\u0121\3\2\2\2")
        buf.write("\u0121\u0123\t\6\2\2\u0122\u0124\7\6\2\2\u0123\u0122\3")
        buf.write("\2\2\2\u0123\u0124\3\2\2\2\u0124\u0126\3\2\2\2\u0125\u0112")
        buf.write("\3\2\2\2\u0125\u011c\3\2\2\2\u0126\25\3\2\2\2\u0127\u0128")
        buf.write("\7\u01c1\2\2\u0128\u012a\t\7\2\2\u0129\u012b\7\u0168\2")
        buf.write("\2\u012a\u0129\3\2\2\2\u012a\u012b\3\2\2\2\u012b\u012e")
        buf.write("\3\2\2\2\u012c\u012d\7\u018e\2\2\u012d\u012f\7\u01c2\2")
        buf.write("\2\u012e\u012c\3\2\2\2\u012e\u012f\3\2\2\2\u012f\27\3")
        buf.write("\2\2\2\u0130\u0131\7\u01bd\2\2\u0131\u0132\7\u021c\2\2")
        buf.write("\u0132\31\3\2\2\2\u0133\u0134\b\16\1\2\u0134\u0189\5j")
        buf.write("\66\2\u0135\u0189\5\u0082B\2\u0136\u0189\5h\65\2\u0137")
        buf.write("\u0138\5l\67\2\u0138\u0139\5\32\16\26\u0139\u0189\3\2")
        buf.write("\2\2\u013a\u0189\5\36\20\2\u013b\u0189\5 \21\2\u013c\u013d")
        buf.write("\5~@\2\u013d\u013e\7\4\2\2\u013e\u0140\3\2\2\2\u013f\u013c")
        buf.write("\3\2\2\2\u013f\u0140\3\2\2\2\u0140\u0141\3\2\2\2\u0141")
        buf.write("\u0155\5\u008aF\2\u0142\u0152\7\5\2\2\u0143\u0145\t\b")
        buf.write("\2\2\u0144\u0143\3\2\2\2\u0144\u0145\3\2\2\2\u0145\u0147")
        buf.write("\3\2\2\2\u0146\u0148\7)\2\2\u0147\u0146\3\2\2\2\u0147")
        buf.write("\u0148\3\2\2\2\u0148\u0149\3\2\2\2\u0149\u014e\5\32\16")
        buf.write("\2\u014a\u014b\t\t\2\2\u014b\u014d\5\32\16\2\u014c\u014a")
        buf.write("\3\2\2\2\u014d\u0150\3\2\2\2\u014e\u014c\3\2\2\2\u014e")
        buf.write("\u014f\3\2\2\2\u014f\u0153\3\2\2\2\u0150\u014e\3\2\2\2")
        buf.write("\u0151\u0153\7\t\2\2\u0152\u0144\3\2\2\2\u0152\u0151\3")
        buf.write("\2\2\2\u0152\u0153\3\2\2\2\u0153\u0154\3\2\2\2\u0154\u0156")
        buf.write("\7\6\2\2\u0155\u0142\3\2\2\2\u0155\u0156\3\2\2\2\u0156")
        buf.write("\u0189\3\2\2\2\u0157\u0189\5\"\22\2\u0158\u0159\7\5\2")
        buf.write("\2\u0159\u015a\5\32\16\2\u015a\u015b\7\6\2\2\u015b\u0189")
        buf.write("\3\2\2\2\u015c\u015d\7\u0135\2\2\u015d\u015e\7\5\2\2\u015e")
        buf.write("\u015f\5\32\16\2\u015f\u0161\7\u008d\2\2\u0160\u0162\5")
        buf.write("\u0086D\2\u0161\u0160\3\2\2\2\u0161\u0162\3\2\2\2\u0162")
        buf.write("\u0164\3\2\2\2\u0163\u0165\5\24\13\2\u0164\u0163\3\2\2")
        buf.write("\2\u0164\u0165\3\2\2\2\u0165\u0167\3\2\2\2\u0166\u0168")
        buf.write("\5\30\r\2\u0167\u0166\3\2\2\2\u0167\u0168\3\2\2\2\u0168")
        buf.write("\u0169\3\2\2\2\u0169\u016a\7\6\2\2\u016a\u0189\3\2\2\2")
        buf.write("\u016b\u016d\7\u00d2\2\2\u016c\u016b\3\2\2\2\u016c\u016d")
        buf.write("\3\2\2\2\u016d\u016e\3\2\2\2\u016e\u0170\7\u0172\2\2\u016f")
        buf.write("\u016c\3\2\2\2\u016f\u0170\3\2\2\2\u0170\u0171\3\2\2\2")
        buf.write("\u0171\u0172\7\5\2\2\u0172\u0173\5\f\7\2\u0173\u0174\7")
        buf.write("\6\2\2\u0174\u0189\3\2\2\2\u0175\u0177\7\u0123\2\2\u0176")
        buf.write("\u0178\5\32\16\2\u0177\u0176\3\2\2\2\u0177\u0178\3\2\2")
        buf.write("\2\u0178\u017e\3\2\2\2\u0179\u017a\7\u0176\2\2\u017a\u017b")
        buf.write("\5\32\16\2\u017b\u017c\7\u008c\2\2\u017c\u017d\5\32\16")
        buf.write("\2\u017d\u017f\3\2\2\2\u017e\u0179\3\2\2\2\u017f\u0180")
        buf.write("\3\2\2\2\u0180\u017e\3\2\2\2\u0180\u0181\3\2\2\2\u0181")
        buf.write("\u0184\3\2\2\2\u0182\u0183\7\u0124\2\2\u0183\u0185\5\32")
        buf.write("\16\2\u0184\u0182\3\2\2\2\u0184\u0185\3\2\2\2\u0185\u0186")
        buf.write("\3\2\2\2\u0186\u0187\7\u0136\2\2\u0187\u0189\3\2\2\2\u0188")
        buf.write("\u0133\3\2\2\2\u0188\u0135\3\2\2\2\u0188\u0136\3\2\2\2")
        buf.write("\u0188\u0137\3\2\2\2\u0188\u013a\3\2\2\2\u0188\u013b\3")
        buf.write("\2\2\2\u0188\u013f\3\2\2\2\u0188\u0157\3\2\2\2\u0188\u0158")
        buf.write("\3\2\2\2\u0188\u015c\3\2\2\2\u0188\u016f\3\2\2\2\u0188")
        buf.write("\u0175\3\2\2\2\u0189\u01cf\3\2\2\2\u018a\u018b\f\23\2")
        buf.write("\2\u018b\u018c\7\r\2\2\u018c\u01ce\5\32\16\24\u018d\u018e")
        buf.write("\f\22\2\2\u018e\u018f\t\n\2\2\u018f\u01ce\5\32\16\23\u0190")
        buf.write("\u0191\f\21\2\2\u0191\u0192\t\13\2\2\u0192\u01ce\5\32")
        buf.write("\16\22\u0193\u0194\f\20\2\2\u0194\u0195\t\f\2\2\u0195")
        buf.write("\u01ce\5\32\16\21\u0196\u0197\f\17\2\2\u0197\u0198\t\r")
        buf.write("\2\2\u0198\u01ce\5\32\16\20\u0199\u019b\f\b\2\2\u019a")
        buf.write("\u019c\7\u00d2\2\2\u019b\u019a\3\2\2\2\u019b\u019c\3\2")
        buf.write("\2\2\u019c\u019d\3\2\2\2\u019d\u019e\7\u00e7\2\2\u019e")
        buf.write("\u019f\5\32\16\2\u019f\u01a0\7{\2\2\u01a0\u01a1\5\32\16")
        buf.write("\t\u01a1\u01ce\3\2\2\2\u01a2\u01a4\f\n\2\2\u01a3\u01a5")
        buf.write("\7\u00d2\2\2\u01a4\u01a3\3\2\2\2\u01a4\u01a5\3\2\2\2\u01a5")
        buf.write("\u01a6\3\2\2\2\u01a6\u01a7\7\u0161\2\2\u01a7\u01aa\5\32")
        buf.write("\16\2\u01a8\u01a9\7\u0154\2\2\u01a9\u01ab\5\32\16\2\u01aa")
        buf.write("\u01a8\3\2\2\2\u01aa\u01ab\3\2\2\2\u01ab\u01ce\3\2\2\2")
        buf.write("\u01ac\u01b4\f\t\2\2\u01ad\u01ae\7\u011f\2\2\u01ae\u01b5")
        buf.write("\7\u00de\2\2\u01af\u01b0\7\u011f\2\2\u01b0\u01b1\7\u00d2")
        buf.write("\2\2\u01b1\u01b5\7\u00de\2\2\u01b2\u01b3\7\u00d2\2\2\u01b3")
        buf.write("\u01b5\7\u00de\2\2\u01b4\u01ad\3\2\2\2\u01b4\u01af\3\2")
        buf.write("\2\2\u01b4\u01b2\3\2\2\2\u01b5\u01ce\3\2\2\2\u01b6\u01b8")
        buf.write("\f\7\2\2\u01b7\u01b9\7\u00d2\2\2\u01b8\u01b7\3\2\2\2\u01b8")
        buf.write("\u01b9\3\2\2\2\u01b9\u01ba\3\2\2\2\u01ba\u01c7\7\u00b9")
        buf.write("\2\2\u01bb\u01be\7\5\2\2\u01bc\u01bf\5\n\6\2\u01bd\u01bf")
        buf.write("\5\34\17\2\u01be\u01bc\3\2\2\2\u01be\u01bd\3\2\2\2\u01be")
        buf.write("\u01bf\3\2\2\2\u01bf\u01c0\3\2\2\2\u01c0\u01c8\7\6\2\2")
        buf.write("\u01c1\u01c2\5~@\2\u01c2\u01c3\7\4\2\2\u01c3\u01c5\3\2")
        buf.write("\2\2\u01c4\u01c1\3\2\2\2\u01c4\u01c5\3\2\2\2\u01c5\u01c6")
        buf.write("\3\2\2\2\u01c6\u01c8\5\u0080A\2\u01c7\u01bb\3\2\2\2\u01c7")
        buf.write("\u01c4\3\2\2\2\u01c8\u01ce\3\2\2\2\u01c9\u01ca\f\4\2\2")
        buf.write("\u01ca\u01ce\5\22\n\2\u01cb\u01cc\f\3\2\2\u01cc\u01ce")
        buf.write("\5\24\13\2\u01cd\u018a\3\2\2\2\u01cd\u018d\3\2\2\2\u01cd")
        buf.write("\u0190\3\2\2\2\u01cd\u0193\3\2\2\2\u01cd\u0196\3\2\2\2")
        buf.write("\u01cd\u0199\3\2\2\2\u01cd\u01a2\3\2\2\2\u01cd\u01ac\3")
        buf.write("\2\2\2\u01cd\u01b6\3\2\2\2\u01cd\u01c9\3\2\2\2\u01cd\u01cb")
        buf.write("\3\2\2\2\u01ce\u01d1\3\2\2\2\u01cf\u01cd\3\2\2\2\u01cf")
        buf.write("\u01d0\3\2\2\2\u01d0\33\3\2\2\2\u01d1\u01cf\3\2\2\2\u01d2")
        buf.write("\u01d7\5\32\16\2\u01d3\u01d4\7\7\2\2\u01d4\u01d6\5\32")
        buf.write("\16\2\u01d5\u01d3\3\2\2\2\u01d6\u01d9\3\2\2\2\u01d7\u01d5")
        buf.write("\3\2\2\2\u01d7\u01d8\3\2\2\2\u01d8\35\3\2\2\2\u01d9\u01d7")
        buf.write("\3\2\2\2\u01da\u01db\t\16\2\2\u01db\u01dc\7)\2\2\u01dc")
        buf.write("\u01dd\5\32\16\2\u01dd\37\3\2\2\2\u01de\u01df\7\u0113")
        buf.write("\2\2\u01df\u01e0\7\u021c\2\2\u01e0\u01e1\t\17\2\2\u01e1")
        buf.write("!\3\2\2\2\u01e2\u01e3\5\u008eH\2\u01e3\u01e6\7\5\2\2\u01e4")
        buf.write("\u01e7\7\t\2\2\u01e5\u01e7\5\34\17\2\u01e6\u01e4\3\2\2")
        buf.write("\2\u01e6\u01e5\3\2\2\2\u01e6\u01e7\3\2\2\2\u01e7\u01e8")
        buf.write("\3\2\2\2\u01e8\u01e9\7\6\2\2\u01e9\u01ea\7\u014a\2\2\u01ea")
        buf.write("\u01ee\7\5\2\2\u01eb\u01ec\7\u01cc\2\2\u01ec\u01ed\7\u0105")
        buf.write("\2\2\u01ed\u01ef\5$\23\2\u01ee\u01eb\3\2\2\2\u01ee\u01ef")
        buf.write("\3\2\2\2\u01ef\u01fc\3\2\2\2\u01f0\u01f1\7\u0138\2\2\u01f1")
        buf.write("\u01f2\7\u0105\2\2\u01f2\u01f4\5D#\2\u01f3\u01f5\t\4\2")
        buf.write("\2\u01f4\u01f3\3\2\2\2\u01f4\u01f5\3\2\2\2\u01f5\u01fa")
        buf.write("\3\2\2\2\u01f6\u01f7\7\u01c9\2\2\u01f7\u01fb\7\u01a8\2")
        buf.write("\2\u01f8\u01f9\7\u01c9\2\2\u01f9\u01fb\7\u01c8\2\2\u01fa")
        buf.write("\u01f6\3\2\2\2\u01fa\u01f8\3\2\2\2\u01fa\u01fb\3\2\2\2")
        buf.write("\u01fb\u01fd\3\2\2\2\u01fc\u01f0\3\2\2\2\u01fc\u01fd\3")
        buf.write("\2\2\2\u01fd\u01ff\3\2\2\2\u01fe\u0200\5&\24\2\u01ff\u01fe")
        buf.write("\3\2\2\2\u01ff\u0200\3\2\2\2\u0200\u0201\3\2\2\2\u0201")
        buf.write("\u0202\7\6\2\2\u0202#\3\2\2\2\u0203\u0208\5B\"\2\u0204")
        buf.write("\u0205\7\7\2\2\u0205\u0207\5B\"\2\u0206\u0204\3\2\2\2")
        buf.write("\u0207\u020a\3\2\2\2\u0208\u0206\3\2\2\2\u0208\u0209\3")
        buf.write("\2\2\2\u0209%\3\2\2\2\u020a\u0208\3\2\2\2\u020b\u020c")
        buf.write("\7\u0115\2\2\u020c\u0214\5(\25\2\u020d\u020e\7\u0115\2")
        buf.write("\2\u020e\u020f\7\u00e7\2\2\u020f\u0210\5(\25\2\u0210\u0211")
        buf.write("\7{\2\2\u0211\u0212\5(\25\2\u0212\u0214\3\2\2\2\u0213")
        buf.write("\u020b\3\2\2\2\u0213\u020d\3\2\2\2\u0214\'\3\2\2\2\u0215")
        buf.write("\u0216\7\u01d1\2\2\u0216\u021d\t\20\2\2\u0217\u0218\5")
        buf.write("\32\16\2\u0218\u0219\t\20\2\2\u0219\u021d\3\2\2\2\u021a")
        buf.write("\u021b\7d\2\2\u021b\u021d\7\u0109\2\2\u021c\u0215\3\2")
        buf.write("\2\2\u021c\u0217\3\2\2\2\u021c\u021a\3\2\2\2\u021d)\3")
        buf.write("\2\2\2\u021e\u021f\7)\2\2\u021f\u0220\5,\27\2\u0220+\3")
        buf.write("\2\2\2\u0221\u0225\5.\30\2\u0222\u0224\5\64\33\2\u0223")
        buf.write("\u0222\3\2\2\2\u0224\u0227\3\2\2\2\u0225\u0223\3\2\2\2")
        buf.write("\u0225\u0226\3\2\2\2\u0226-\3\2\2\2\u0227\u0225\3\2\2")
        buf.write("\2\u0228\u022b\5\60\31\2\u0229\u022b\5\62\32\2\u022a\u0228")
        buf.write("\3\2\2\2\u022a\u0229\3\2\2\2\u022b/\3\2\2\2\u022c\u0231")
        buf.write("\5\u0080A\2\u022d\u022f\7\u008d\2\2\u022e\u022d\3\2\2")
        buf.write("\2\u022e\u022f\3\2\2\2\u022f\u0230\3\2\2\2\u0230\u0232")
        buf.write("\5\u0084C\2\u0231\u022e\3\2\2\2\u0231\u0232\3\2\2\2\u0232")
        buf.write("\61\3\2\2\2\u0233\u0234\7\5\2\2\u0234\u0235\5\f\7\2\u0235")
        buf.write("\u0237\7\6\2\2\u0236\u0238\7\u008d\2\2\u0237\u0236\3\2")
        buf.write("\2\2\u0237\u0238\3\2\2\2\u0238\u0239\3\2\2\2\u0239\u023e")
        buf.write("\5v<\2\u023a\u023b\7\5\2\2\u023b\u023c\5h\65\2\u023c\u023d")
        buf.write("\7\6\2\2\u023d\u023f\3\2\2\2\u023e\u023a\3\2\2\2\u023e")
        buf.write("\u023f\3\2\2\2\u023f\63\3\2\2\2\u0240\u0246\7\u00d7\2")
        buf.write("\2\u0241\u0243\t\21\2\2\u0242\u0244\7\u0144\2\2\u0243")
        buf.write("\u0242\3\2\2\2\u0243\u0244\3\2\2\2\u0244\u0246\3\2\2\2")
        buf.write("\u0245\u0240\3\2\2\2\u0245\u0241\3\2\2\2\u0245\u0246\3")
        buf.write("\2\2\2\u0246\u0247\3\2\2\2\u0247\u0248\7\u012b\2\2\u0248")
        buf.write("\u0249\5.\30\2\u0249\u024a\7\u011a\2\2\u024a\u024b\5d")
        buf.write("\63\2\u024b\u0252\3\2\2\2\u024c\u024d\7L\2\2\u024d\u024e")
        buf.write("\7\u012b\2\2\u024e\u0252\5.\30\2\u024f\u0250\7\7\2\2\u0250")
        buf.write("\u0252\5.\30\2\u0251\u0245\3\2\2\2\u0251\u024c\3\2\2\2")
        buf.write("\u0251\u024f\3\2\2\2\u0252\65\3\2\2\2\u0253\u0254\7\u018e")
        buf.write("\2\2\u0254\u0264\5\34\17\2\u0255\u0256\7\u0105\2\2\u0256")
        buf.write("\u0258\5\32\16\2\u0257\u0259\t\4\2\2\u0258\u0257\3\2\2")
        buf.write("\2\u0258\u0259\3\2\2\2\u0259\u0261\3\2\2\2\u025a\u025b")
        buf.write("\7\7\2\2\u025b\u025d\5\32\16\2\u025c\u025e\t\4\2\2\u025d")
        buf.write("\u025c\3\2\2\2\u025d\u025e\3\2\2\2\u025e\u0260\3\2\2\2")
        buf.write("\u025f\u025a\3\2\2\2\u0260\u0263\3\2\2\2\u0261\u025f\3")
        buf.write("\2\2\2\u0261\u0262\3\2\2\2\u0262\u0265\3\2\2\2\u0263\u0261")
        buf.write("\3\2\2\2\u0264\u0255\3\2\2\2\u0264\u0265\3\2\2\2\u0265")
        buf.write("\67\3\2\2\2\u0266\u0267\7\u017c\2\2\u0267\u0268\5d\63")
        buf.write("\2\u02689\3\2\2\2\u0269\u026c\5<\37\2\u026a\u026c\5> ")
        buf.write("\2\u026b\u0269\3\2\2\2\u026b\u026a\3\2\2\2\u026c;\3\2")
        buf.write("\2\2\u026d\u026e\7\u0095\2\2\u026e\u026f\5f\64\2\u026f")
        buf.write("=\3\2\2\2\u0270\u0271\7%\2\2\u0271\u0272\5d\63\2\u0272")
        buf.write("?\3\2\2\2\u0273\u0278\5B\"\2\u0274\u0275\7\7\2\2\u0275")
        buf.write("\u0277\5B\"\2\u0276\u0274\3\2\2\2\u0277\u027a\3\2\2\2")
        buf.write("\u0278\u0276\3\2\2\2\u0278\u0279\3\2\2\2\u0279A\3\2\2")
        buf.write("\2\u027a\u0278\3\2\2\2\u027b\u027e\5H%\2\u027c\u027e\5")
        buf.write("J&\2\u027d\u027b\3\2\2\2\u027d\u027c\3\2\2\2\u027eC\3")
        buf.write("\2\2\2\u027f\u0284\5F$\2\u0280\u0281\7\7\2\2\u0281\u0283")
        buf.write("\5F$\2\u0282\u0280\3\2\2\2\u0283\u0286\3\2\2\2\u0284\u0282")
        buf.write("\3\2\2\2\u0284\u0285\3\2\2\2\u0285E\3\2\2\2\u0286\u0284")
        buf.write("\3\2\2\2\u0287\u0289\5\32\16\2\u0288\u028a\t\4\2\2\u0289")
        buf.write("\u0288\3\2\2\2\u0289\u028a\3\2\2\2\u028a\u028f\3\2\2\2")
        buf.write("\u028b\u028c\7\u01c9\2\2\u028c\u0290\7\u01a8\2\2\u028d")
        buf.write("\u028e\7\u01c9\2\2\u028e\u0290\7\u01c8\2\2\u028f\u028b")
        buf.write("\3\2\2\2\u028f\u028d\3\2\2\2\u028f\u0290\3\2\2\2\u0290")
        buf.write("\u02b0\3\2\2\2\u0291\u0293\5\u0082B\2\u0292\u0294\t\4")
        buf.write("\2\2\u0293\u0292\3\2\2\2\u0293\u0294\3\2\2\2\u0294\u0299")
        buf.write("\3\2\2\2\u0295\u0296\7\u01c9\2\2\u0296\u029a\7\u01a8\2")
        buf.write("\2\u0297\u0298\7\u01c9\2\2\u0298\u029a\7\u01c8\2\2\u0299")
        buf.write("\u0295\3\2\2\2\u0299\u0297\3\2\2\2\u0299\u029a\3\2\2\2")
        buf.write("\u029a\u02b0\3\2\2\2\u029b\u029d\5p9\2\u029c\u029e\t\4")
        buf.write("\2\2\u029d\u029c\3\2\2\2\u029d\u029e\3\2\2\2\u029e\u02a3")
        buf.write("\3\2\2\2\u029f\u02a0\7\u01c9\2\2\u02a0\u02a4\7\u01a8\2")
        buf.write("\2\u02a1\u02a2\7\u01c9\2\2\u02a2\u02a4\7\u01c8\2\2\u02a3")
        buf.write("\u029f\3\2\2\2\u02a3\u02a1\3\2\2\2\u02a3\u02a4\3\2\2\2")
        buf.write("\u02a4\u02b0\3\2\2\2\u02a5\u02a7\5b\62\2\u02a6\u02a8\t")
        buf.write("\4\2\2\u02a7\u02a6\3\2\2\2\u02a7\u02a8\3\2\2\2\u02a8\u02ad")
        buf.write("\3\2\2\2\u02a9\u02aa\7\u01c9\2\2\u02aa\u02ae\7\u01a8\2")
        buf.write("\2\u02ab\u02ac\7\u01c9\2\2\u02ac\u02ae\7\u01c8\2\2\u02ad")
        buf.write("\u02a9\3\2\2\2\u02ad\u02ab\3\2\2\2\u02ad\u02ae\3\2\2\2")
        buf.write("\u02ae\u02b0\3\2\2\2\u02af\u0287\3\2\2\2\u02af\u0291\3")
        buf.write("\2\2\2\u02af\u029b\3\2\2\2\u02af\u02a5\3\2\2\2\u02b0G")
        buf.write("\3\2\2\2\u02b1\u02b5\5\u0082B\2\u02b2\u02b5\5b\62\2\u02b3")
        buf.write("\u02b5\5\32\16\2\u02b4\u02b1\3\2\2\2\u02b4\u02b2\3\2\2")
        buf.write("\2\u02b4\u02b3\3\2\2\2\u02b5I\3\2\2\2\u02b6\u02b7\7\5")
        buf.write("\2\2\u02b7\u02b8\7\6\2\2\u02b8K\3\2\2\2\u02b9\u02bb\t")
        buf.write("\22\2\2\u02ba\u02bc\7\u0119\2\2\u02bb\u02ba\3\2\2\2\u02bb")
        buf.write("\u02bc\3\2\2\2\u02bc\u02bd\3\2\2\2\u02bd\u02bf\5\u0080")
        buf.write("A\2\u02be\u02c0\7\5\2\2\u02bf\u02be\3\2\2\2\u02bf\u02c0")
        buf.write("\3\2\2\2\u02c0\u02c2\3\2\2\2\u02c1\u02c3\5h\65\2\u02c2")
        buf.write("\u02c1\3\2\2\2\u02c2\u02c3\3\2\2\2\u02c3\u02c5\3\2\2\2")
        buf.write("\u02c4\u02c6\7\6\2\2\u02c5\u02c4\3\2\2\2\u02c5\u02c6\3")
        buf.write("\2\2\2\u02c6\u02c8\3\2\2\2\u02c7\u02c9\7\u013a\2\2\u02c8")
        buf.write("\u02c7\3\2\2\2\u02c8\u02c9\3\2\2\2\u02c9\u02ca\3\2\2\2")
        buf.write("\u02ca\u02cb\7\5\2\2\u02cb\u02cc\5\34\17\2\u02cc\u02cd")
        buf.write("\7\6\2\2\u02cd\u02e9\3\2\2\2\u02ce\u02d0\t\22\2\2\u02cf")
        buf.write("\u02d1\7\u0119\2\2\u02d0\u02cf\3\2\2\2\u02d0\u02d1\3\2")
        buf.write("\2\2\u02d1\u02d2\3\2\2\2\u02d2\u02d4\5\u0080A\2\u02d3")
        buf.write("\u02d5\7\5\2\2\u02d4\u02d3\3\2\2\2\u02d4\u02d5\3\2\2\2")
        buf.write("\u02d5\u02d7\3\2\2\2\u02d6\u02d8\5h\65\2\u02d7\u02d6\3")
        buf.write("\2\2\2\u02d7\u02d8\3\2\2\2\u02d8\u02da\3\2\2\2\u02d9\u02db")
        buf.write("\7\6\2\2\u02da\u02d9\3\2\2\2\u02da\u02db\3\2\2\2\u02db")
        buf.write("\u02dc\3\2\2\2\u02dc\u02de\5\f\7\2\u02dd\u02df\5N(\2\u02de")
        buf.write("\u02dd\3\2\2\2\u02de\u02df\3\2\2\2\u02df\u02e9\3\2\2\2")
        buf.write("\u02e0\u02e2\t\22\2\2\u02e1\u02e3\7\u0119\2\2\u02e2\u02e1")
        buf.write("\3\2\2\2\u02e2\u02e3\3\2\2\2\u02e3\u02e4\3\2\2\2\u02e4")
        buf.write("\u02e5\5\u0080A\2\u02e5\u02e6\7\u00be\2\2\u02e6\u02e7")
        buf.write("\7\u013a\2\2\u02e7\u02e9\3\2\2\2\u02e8\u02b9\3\2\2\2\u02e8")
        buf.write("\u02ce\3\2\2\2\u02e8\u02e0\3\2\2\2\u02e9M\3\2\2\2\u02ea")
        buf.write("\u02ec\7\u0197\2\2\u02eb\u02ed\7i\2\2\u02ec\u02eb\3\2")
        buf.write("\2\2\u02ec\u02ed\3\2\2\2\u02ed\u02ee\3\2\2\2\u02ee\u02f7")
        buf.write("\7\u01ca\2\2\u02ef\u02f5\7\u018e\2\2\u02f0\u02f1\7\u00c6")
        buf.write("\2\2\u02f1\u02f6\7\u0167\2\2\u02f2\u02f3\7\u0167\2\2\u02f3")
        buf.write("\u02f4\7\u0102\2\2\u02f4\u02f6\7\u0217\2\2\u02f5\u02f0")
        buf.write("\3\2\2\2\u02f5\u02f2\3\2\2\2\u02f6\u02f8\3\2\2\2\u02f7")
        buf.write("\u02ef\3\2\2\2\u02f7\u02f8\3\2\2\2\u02f8O\3\2\2\2\u02f9")
        buf.write("\u02fc\t\23\2\2\u02fa\u02fd\5\u0084C\2\u02fb\u02fd\5\u0080")
        buf.write("A\2\u02fc\u02fa\3\2\2\2\u02fc\u02fb\3\2\2\2\u02fc\u02fd")
        buf.write("\3\2\2\2\u02fd\u02ff\3\2\2\2\u02fe\u0300\5*\26\2\u02ff")
        buf.write("\u02fe\3\2\2\2\u02ff\u0300\3\2\2\2\u0300\u0303\3\2\2\2")
        buf.write("\u0301\u0304\58\35\2\u0302\u0304\7i\2\2\u0303\u0301\3")
        buf.write("\2\2\2\u0303\u0302\3\2\2\2\u0303\u0304\3\2\2\2\u0304Q")
        buf.write("\3\2\2\2\u0305\u0306\t\24\2\2\u0306\u0307\5\u0080A\2\u0307")
        buf.write("\u0308\7\u014b\2\2\u0308\u030b\5T+\2\u0309\u030c\58\35")
        buf.write("\2\u030a\u030c\7i\2\2\u030b\u0309\3\2\2\2\u030b\u030a")
        buf.write("\3\2\2\2\u030b\u030c\3\2\2\2\u030c\u0322\3\2\2\2\u030d")
        buf.write("\u0310\t\24\2\2\u030e\u0311\5\u0084C\2\u030f\u0311\5\u0080")
        buf.write("A\2\u0310\u030e\3\2\2\2\u0310\u030f\3\2\2\2\u0310\u0311")
        buf.write("\3\2\2\2\u0311\u0312\3\2\2\2\u0312\u0313\5*\26\2\u0313")
        buf.write("\u0314\7\u014b\2\2\u0314\u0317\5T+\2\u0315\u0318\58\35")
        buf.write("\2\u0316\u0318\7i\2\2\u0317\u0315\3\2\2\2\u0317\u0316")
        buf.write("\3\2\2\2\u0317\u0318\3\2\2\2\u0318\u0322\3\2\2\2\u0319")
        buf.write("\u031a\t\24\2\2\u031a\u031b\5\u0080A\2\u031b\u031c\7\u014b")
        buf.write("\2\2\u031c\u031d\5T+\2\u031d\u031e\58\35\2\u031e\u031f")
        buf.write("\7\u0124\2\2\u031f\u0320\5L\'\2\u0320\u0322\3\2\2\2\u0321")
        buf.write("\u0305\3\2\2\2\u0321\u030d\3\2\2\2\u0321\u0319\3\2\2\2")
        buf.write("\u0322S\3\2\2\2\u0323\u0324\5\34\17\2\u0324U\3\2\2\2\u0325")
        buf.write("\u0327\7\66\2\2\u0326\u0328\7\u0119\2\2\u0327\u0326\3")
        buf.write("\2\2\2\u0327\u0328\3\2\2\2\u0328\u0329\3\2\2\2\u0329\u032a")
        buf.write("\5X-\2\u032a\u032b\7\u012e\2\2\u032b\u032c\5Z.\2\u032c")
        buf.write("\u032d\7\u011a\2\2\u032d\u032f\5\\/\2\u032e\u0330\5^\60")
        buf.write("\2\u032f\u032e\3\2\2\2\u032f\u0330\3\2\2\2\u0330\u0332")
        buf.write("\3\2\2\2\u0331\u0333\5`\61\2\u0332\u0331\3\2\2\2\u0332")
        buf.write("\u0333\3\2\2\2\u0333W\3\2\2\2\u0334\u0336\5\u0080A\2\u0335")
        buf.write("\u0337\7\u008d\2\2\u0336\u0335\3\2\2\2\u0336\u0337\3\2")
        buf.write("\2\2\u0337\u0339\3\2\2\2\u0338\u033a\5\u0084C\2\u0339")
        buf.write("\u0338\3\2\2\2\u0339\u033a\3\2\2\2\u033aY\3\2\2\2\u033b")
        buf.write("\u0347\5\62\32\2\u033c\u033e\5\u0080A\2\u033d\u033f\7")
        buf.write("\5\2\2\u033e\u033d\3\2\2\2\u033e\u033f\3\2\2\2\u033f\u0341")
        buf.write("\3\2\2\2\u0340\u0342\5h\65\2\u0341\u0340\3\2\2\2\u0341")
        buf.write("\u0342\3\2\2\2\u0342\u0344\3\2\2\2\u0343\u0345\7\6\2\2")
        buf.write("\u0344\u0343\3\2\2\2\u0344\u0345\3\2\2\2\u0345\u0347\3")
        buf.write("\2\2\2\u0346\u033b\3\2\2\2\u0346\u033c\3\2\2\2\u0347\u0349")
        buf.write("\3\2\2\2\u0348\u034a\7\u008d\2\2\u0349\u0348\3\2\2\2\u0349")
        buf.write("\u034a\3\2\2\2\u034a\u034c\3\2\2\2\u034b\u034d\5\u0084")
        buf.write("C\2\u034c\u034b\3\2\2\2\u034c\u034d\3\2\2\2\u034d[\3\2")
        buf.write("\2\2\u034e\u034f\5\34\17\2\u034f]\3\2\2\2\u0350\u0351")
        buf.write("\7\u0176\2\2\u0351\u0352\7\u01cb\2\2\u0352\u0353\7\u008c")
        buf.write("\2\2\u0353\u0354\t\24\2\2\u0354\u0355\7\u014b\2\2\u0355")
        buf.write("\u0356\5\34\17\2\u0356_\3\2\2\2\u0357\u0358\7\u0176\2")
        buf.write("\2\u0358\u0359\7\u00d2\2\2\u0359\u035a\7\u01cb\2\2\u035a")
        buf.write("\u035b\7\u008c\2\2\u035b\u035d\t\22\2\2\u035c\u035e\7")
        buf.write("\5\2\2\u035d\u035c\3\2\2\2\u035d\u035e\3\2\2\2\u035e\u0360")
        buf.write("\3\2\2\2\u035f\u0361\5h\65\2\u0360\u035f\3\2\2\2\u0360")
        buf.write("\u0361\3\2\2\2\u0361\u0363\3\2\2\2\u0362\u0364\7\6\2\2")
        buf.write("\u0363\u0362\3\2\2\2\u0363\u0364\3\2\2\2\u0364\u0366\3")
        buf.write("\2\2\2\u0365\u0367\7\u013a\2\2\u0366\u0365\3\2\2\2\u0366")
        buf.write("\u0367\3\2\2\2\u0367\u0368\3\2\2\2\u0368\u0369\7\5\2\2")
        buf.write("\u0369\u036a\5\34\17\2\u036a\u036c\7\6\2\2\u036b\u036d")
        buf.write("\5N(\2\u036c\u036b\3\2\2\2\u036c\u036d\3\2\2\2\u036da")
        buf.write("\3\2\2\2\u036e\u036f\7\u0218\2\2\u036fc\3\2\2\2\u0370")
        buf.write("\u037a\5\32\16\2\u0371\u037b\7\24\2\2\u0372\u037b\7\25")
        buf.write("\2\2\u0373\u037b\7\26\2\2\u0374\u037b\7\27\2\2\u0375\u037b")
        buf.write("\7\b\2\2\u0376\u037b\7\32\2\2\u0377\u037b\7\u00b9\2\2")
        buf.write("\u0378\u0379\7\u00d2\2\2\u0379\u037b\7\u00b9\2\2\u037a")
        buf.write("\u0371\3\2\2\2\u037a\u0372\3\2\2\2\u037a\u0373\3\2\2\2")
        buf.write("\u037a\u0374\3\2\2\2\u037a\u0375\3\2\2\2\u037a\u0376\3")
        buf.write("\2\2\2\u037a\u0377\3\2\2\2\u037a\u0378\3\2\2\2\u037b\u037c")
        buf.write("\3\2\2\2\u037c\u037d\7\5\2\2\u037d\u037e\5\f\7\2\u037e")
        buf.write("\u037f\7\6\2\2\u037f\u038e\3\2\2\2\u0380\u0381\7\5\2\2")
        buf.write("\u0381\u0382\5h\65\2\u0382\u0386\7\6\2\2\u0383\u0387\7")
        buf.write("\u00b9\2\2\u0384\u0385\7\u00d2\2\2\u0385\u0387\7\u00b9")
        buf.write("\2\2\u0386\u0383\3\2\2\2\u0386\u0384\3\2\2\2\u0387\u0388")
        buf.write("\3\2\2\2\u0388\u0389\7\5\2\2\u0389\u038a\5\f\7\2\u038a")
        buf.write("\u038b\7\6\2\2\u038b\u038e\3\2\2\2\u038c\u038e\5\32\16")
        buf.write("\2\u038d\u0370\3\2\2\2\u038d\u0380\3\2\2\2\u038d\u038c")
        buf.write("\3\2\2\2\u038ee\3\2\2\2\u038f\u0390\5\32\16\2\u0390g\3")
        buf.write("\2\2\2\u0391\u0396\5\u0082B\2\u0392\u0393\7\7\2\2\u0393")
        buf.write("\u0395\5\u0082B\2\u0394\u0392\3\2\2\2\u0395\u0398\3\2")
        buf.write("\2\2\u0396\u0394\3\2\2\2\u0396\u0397\3\2\2\2\u0397i\3")
        buf.write("\2\2\2\u0398\u0396\3\2\2\2\u0399\u03a0\7\u0217\2\2\u039a")
        buf.write("\u03a0\7\u021c\2\2\u039b\u03a0\7\u00de\2\2\u039c\u03a0")
        buf.write("\5x=\2\u039d\u03a0\5|?\2\u039e\u03a0\5z>\2\u039f\u0399")
        buf.write("\3\2\2\2\u039f\u039a\3\2\2\2\u039f\u039b\3\2\2\2\u039f")
        buf.write("\u039c\3\2\2\2\u039f\u039d\3\2\2\2\u039f\u039e\3\2\2\2")
        buf.write("\u03a0k\3\2\2\2\u03a1\u03a2\t\25\2\2\u03a2m\3\2\2\2\u03a3")
        buf.write("\u03a5\7\u00fe\2\2\u03a4\u03a6\7i\2\2\u03a5\u03a4\3\2")
        buf.write("\2\2\u03a5\u03a6\3\2\2\2\u03a6\u03b4\3\2\2\2\u03a7\u03a9")
        buf.write("\7\u010d\2\2\u03a8\u03aa\7i\2\2\u03a9\u03a8\3\2\2\2\u03a9")
        buf.write("\u03aa\3\2\2\2\u03aa\u03b4\3\2\2\2\u03ab\u03ad\7N\2\2")
        buf.write("\u03ac\u03ae\7i\2\2\u03ad\u03ac\3\2\2\2\u03ad\u03ae\3")
        buf.write("\2\2\2\u03ae\u03b4\3\2\2\2\u03af\u03b1\7\u0160\2\2\u03b0")
        buf.write("\u03b2\7i\2\2\u03b1\u03b0\3\2\2\2\u03b1\u03b2\3\2\2\2")
        buf.write("\u03b2\u03b4\3\2\2\2\u03b3\u03a3\3\2\2\2\u03b3\u03a7\3")
        buf.write("\2\2\2\u03b3\u03ab\3\2\2\2\u03b3\u03af\3\2\2\2\u03b4o")
        buf.write("\3\2\2\2\u03b5\u03b6\7\u021b\2\2\u03b6q\3\2\2\2\u03b7")
        buf.write("\u03b8\7\u021b\2\2\u03b8s\3\2\2\2\u03b9\u03ba\7\u021b")
        buf.write("\2\2\u03bau\3\2\2\2\u03bb\u03bc\5\u0080A\2\u03bcw\3\2")
        buf.write("\2\2\u03bd\u03bf\7\u009a\2\2\u03be\u03bd\3\2\2\2\u03be")
        buf.write("\u03bf\3\2\2\2\u03bf\u03c0\3\2\2\2\u03c0\u03c1\7\u021c")
        buf.write("\2\2\u03c1y\3\2\2\2\u03c2\u03c4\7\u009e\2\2\u03c3\u03c2")
        buf.write("\3\2\2\2\u03c3\u03c4\3\2\2\2\u03c4\u03c5\3\2\2\2\u03c5")
        buf.write("\u03c6\7\u021c\2\2\u03c6{\3\2\2\2\u03c7\u03c9\7\u0098")
        buf.write("\2\2\u03c8\u03c7\3\2\2\2\u03c8\u03c9\3\2\2\2\u03c9\u03ca")
        buf.write("\3\2\2\2\u03ca\u03cb\7\u021c\2\2\u03cb}\3\2\2\2\u03cc")
        buf.write("\u03cd\7\u021b\2\2\u03cd\177\3\2\2\2\u03ce\u03cf\5~@\2")
        buf.write("\u03cf\u03d0\7\4\2\2\u03d0\u03d2\3\2\2\2\u03d1\u03ce\3")
        buf.write("\2\2\2\u03d1\u03d2\3\2\2\2\u03d2\u03d3\3\2\2\2\u03d3\u03d4")
        buf.write("\7\u021b\2\2\u03d4\u0081\3\2\2\2\u03d5\u03d6\5\u0084C")
        buf.write("\2\u03d6\u03d7\7\4\2\2\u03d7\u03d9\3\2\2\2\u03d8\u03d5")
        buf.write("\3\2\2\2\u03d8\u03d9\3\2\2\2\u03d9\u03da\3\2\2\2\u03da")
        buf.write("\u03e2\7\u021b\2\2\u03db\u03dc\5\u0080A\2\u03dc\u03dd")
        buf.write("\7\4\2\2\u03dd\u03df\3\2\2\2\u03de\u03db\3\2\2\2\u03de")
        buf.write("\u03df\3\2\2\2\u03df\u03e0\3\2\2\2\u03e0\u03e2\7\u021b")
        buf.write("\2\2\u03e1\u03d8\3\2\2\2\u03e1\u03de\3\2\2\2\u03e2\u0083")
        buf.write("\3\2\2\2\u03e3\u03e4\7\u021b\2\2\u03e4\u0085\3\2\2\2\u03e5")
        buf.write("\u03ed\5\u0088E\2\u03e6\u03e8\7\5\2\2\u03e7\u03e9\t\26")
        buf.write("\2\2\u03e8\u03e7\3\2\2\2\u03e9\u03ea\3\2\2\2\u03ea\u03e8")
        buf.write("\3\2\2\2\u03ea\u03eb\3\2\2\2\u03eb\u03ec\3\2\2\2\u03ec")
        buf.write("\u03ee\7\6\2\2\u03ed\u03e6\3\2\2\2\u03ed\u03ee\3\2\2\2")
        buf.write("\u03ee\u0087\3\2\2\2\u03ef\u03f0\t\27\2\2\u03f0\u0089")
        buf.write("\3\2\2\2\u03f1\u03f5\5\u008cG\2\u03f2\u03f5\5\u008eH\2")
        buf.write("\u03f3\u03f5\5\u0090I\2\u03f4\u03f1\3\2\2\2\u03f4\u03f2")
        buf.write("\3\2\2\2\u03f4\u03f3\3\2\2\2\u03f5\u008b\3\2\2\2\u03f6")
        buf.write("\u03f7\t\30\2\2\u03f7\u008d\3\2\2\2\u03f8\u03f9\t\31\2")
        buf.write("\2\u03f9\u008f\3\2\2\2\u03fa\u03fb\7\u021b\2\2\u03fb\u0091")
        buf.write("\3\2\2\2\u0098\u0096\u00a0\u00a3\u00ad\u00c1\u00c4\u00c8")
        buf.write("\u00cb\u00ce\u00d3\u00d6\u00dc\u00e2\u00e4\u00ec\u00f0")
        buf.write("\u00fb\u00fe\u0102\u0105\u010b\u0112\u0115\u0119\u011c")
        buf.write("\u011f\u0123\u0125\u012a\u012e\u013f\u0144\u0147\u014e")
        buf.write("\u0152\u0155\u0161\u0164\u0167\u016c\u016f\u0177\u0180")
        buf.write("\u0184\u0188\u019b\u01a4\u01aa\u01b4\u01b8\u01be\u01c4")
        buf.write("\u01c7\u01cd\u01cf\u01d7\u01e6\u01ee\u01f4\u01fa\u01fc")
        buf.write("\u01ff\u0208\u0213\u021c\u0225\u022a\u022e\u0231\u0237")
        buf.write("\u023e\u0243\u0245\u0251\u0258\u025d\u0261\u0264\u026b")
        buf.write("\u0278\u027d\u0284\u0289\u028f\u0293\u0299\u029d\u02a3")
        buf.write("\u02a7\u02ad\u02af\u02b4\u02bb\u02bf\u02c2\u02c5\u02c8")
        buf.write("\u02d0\u02d4\u02d7\u02da\u02de\u02e2\u02e8\u02ec\u02f5")
        buf.write("\u02f7\u02fc\u02ff\u0303\u030b\u0310\u0317\u0321\u0327")
        buf.write("\u032f\u0332\u0336\u0339\u033e\u0341\u0344\u0346\u0349")
        buf.write("\u034c\u035d\u0360\u0363\u0366\u036c\u037a\u0386\u038d")
        buf.write("\u0396\u039f\u03a5\u03a9\u03ad\u03b1\u03b3\u03be\u03c3")
        buf.write("\u03c8\u03d1\u03d8\u03de\u03e1\u03ea\u03ed\u03f4")
        return buf.getvalue()


class TDantlrParser ( Parser ):

    grammarFileName = "TDantlr.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'.'", "'('", "')'", "','", "'='", 
                     "'*'", "'+'", "'-'", "'~'", "'||'", "'/'", "'%'", "'<<'", 
                     "'>>'", "'&'", "'|'", "'<'", "'<='", "'>'", "'>='", 
                     "'=='", "'!='", "'<>'" ]

    symbolicNames = [ "<INVALID>", "SCOL", "DOT", "OPEN_PAR", "CLOSE_PAR", 
                      "COMMA", "ASSIGN", "STAR", "PLUS", "MINUS", "TILDE", 
                      "PIPE2", "DIV", "MOD", "LT2", "GT2", "AMP", "PIPE", 
                      "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", "NOT_EQ2", 
                      "K_ABORT", "K_CONVERT_TABLE_HEADER", "K_FOUND", "K_MAX", 
                      "K_QUALIFIED", "K_STATEMENT", "K_ABORTSESSION", "K_CORR", 
                      "K_FREESPACE", "K_MAXIMUM", "K_QUALIFY", "K_STATISTICS", 
                      "K_ABS", "K_COS", "K_FROM", "K_MCHARACTERS", "K_QUANTILE", 
                      "K_STDDEV_POP", "K_ACCESS_LOCK", "K_COSH", "K_FULL", 
                      "K_MDIFF", "K_RADIANS", "K_STDDEV_SAMP", "K_ACCOUNT", 
                      "K_COUNT", "K_FUNCTION", "K_MERGE", "K_RANDOM", "K_STEPINFO", 
                      "K_ACOS", "K_COVAR_POP", "K_GE", "K_MIN", "K_RANGE_N", 
                      "K_STRING_CS", "K_ACOSH", "K_COVAR_SAMP", "K_GENERATED", 
                      "K_MINDEX", "K_RANK", "K_SUBSCRIBER", "K_ADD", "K_CREATE", 
                      "K_GIVE", "K_MINIMUM", "K_REAL", "K_SUBSTR", "K_ADD_MONTHS", 
                      "K_CROSS", "K_GO", "K_MINUS", "K_REFERENCES", "K_SUBSTRING", 
                      "K_ADMIN", "K_CS", "K_GOTO", "K_MINUTE", "K_REFERENCING", 
                      "K_SUM", "K_AFTER", "K_CSUM", "K_GRANT", "K_MLINREG", 
                      "K_REGR_AVGX", "K_SUMMARY", "K_AGGREGATE", "K_CT", 
                      "K_GRAPHIC", "K_MLOAD", "K_REGR_AVGY", "K_SUSPEND", 
                      "K_ALIAS", "K_CURRENT", "K_GROUP", "K_MOD", "K_REGR_COUNT", 
                      "K_TABLE", "K_ALL", "K_CURRENT_DATE", "K_GT", "K_MODE", 
                      "K_REGR_INTERCEPT", "K_TAN", "K_ALTER", "K_CURRENT_TIME", 
                      "K_HANDLER", "K_MODIFY", "K_REGR_R2", "K_TANH", "K_AMP", 
                      "K_CURRENT_TIMESTAMP", "K_HASH", "K_MONITOR", "K_REGR_SLOPE", 
                      "K_TBL_CS", "K_AND", "K_CURSOR", "K_HASHAMP", "K_MONRESOURCE", 
                      "K_REGR_SXX", "K_TEMPORARY", "K_ANSIDATE", "K_CV", 
                      "K_HASHBAKAMP", "K_MONSESSION", "K_REGR_SXY", "K_TERMINATE", 
                      "K_ANY", "K_CYCLE", "K_HASHBUCKET", "K_MONTH", "K_REGR_SYY", 
                      "K_THEN", "K_AS", "K_DATABASE", "K_HASHROW", "K_MSUBSTR", 
                      "K_RELEASE", "K_THRESHOLD", "K_ASC", "K_DATABLOCKSIZE", 
                      "K_HAVING", "K_MSUM", "K_RENAME", "K_TIME", "K_ASIN", 
                      "K_DATE", "K_HELP", "K_MULTISET", "K_REPEAT", "K_TIMESTAMP", 
                      "K_ASINH", "K_DATEFORM", "K_HOUR", "K_NAMED", "K_REPLACE", 
                      "K_TIMEZONE_HOUR", "K_AT", "K_DAY", "K_IDENTITY", 
                      "K_NATURAL", "K_REPLICATION", "K_TIMEZONE_MINUTE", 
                      "K_ATAN", "K_DEC", "K_IF", "K_NE", "K_REPOVERRIDE", 
                      "K_TITLE", "K_ATAN2", "K_DECIMAL", "K_IMMEDIATE", 
                      "K_NEW", "K_REQUEST", "K_TO", "K_ATANH", "K_DECLARE", 
                      "K_IN", "K_NEW_TABLE", "K_RESTART", "K_TRACE", "K_ATOMIC", 
                      "K_DEFAULT", "K_INCONSISTENT", "K_NEXT", "K_RESTORE", 
                      "K_TRAILING", "K_AUTHORIZATION", "K_DEGREES", "K_INDEX", 
                      "K_NO", "K_RESUME", "K_TRANSACTION", "K_AVE", "K_DEL", 
                      "K_INDICATOR", "K_NONE", "K_RET", "K_TRANSLATE", "K_AVERAGE", 
                      "K_DELETE", "K_INITIATE", "K_NOT", "K_RETRIEVE", "K_TRANSLATE_CHK", 
                      "K_AVG", "K_DESC", "K_INNER", "K_NOWAIT", "K_RETURNS", 
                      "K_TRIGGER", "K_BEFORE", "K_DESCRIPTOR", "K_INOUT", 
                      "K_NULL", "K_REVALIDATE", "K_TRIM", "K_BEGIN", "K_DETERMINISTIC", 
                      "K_INPUT", "K_NULLIF", "K_REVOKE", "K_TYPE", "K_BETWEEN", 
                      "K_DIAGNOSTIC", "K_INS", "K_NULLIFZERO", "K_RIGHT", 
                      "K_UC", "K_BLOB", "K_DISABLED", "K_INSERT", "K_NUMERIC", 
                      "K_RIGHTS", "K_UNDEFINED", "K_BOTH", "K_DISTINCT", 
                      "K_INSTEAD", "K_OBJECTS", "K_ROLE", "K_UNDO", "K_BT", 
                      "K_DO", "K_INT", "K_OCTET_LENGTH", "K_ROLLBACK", "K_UNION", 
                      "K_BUT", "K_DOUBLE", "K_INTEGER", "K_OF", "K_ROLLFORWARD", 
                      "K_UNIQUE", "K_BY", "K_DROP", "K_INTEGERDATE", "K_OFF", 
                      "K_ROW", "K_UNTIL", "K_BYTE", "K_DUAL", "K_INTERSECT", 
                      "K_OLD", "K_ROWID", "K_UPD", "K_BYTEINT", "K_DUMP", 
                      "K_INTERVAL", "K_OLD_TABLE", "K_ROWS", "K_UPDATE", 
                      "K_BYTES", "K_EACH", "K_INTO", "K_ON", "K_ROW_NUMBER", 
                      "K_UPPER", "K_CALL", "K_ECHO", "K_IS", "K_ONLY", "K_SAMPLE", 
                      "K_UPPERCASE", "K_CASE", "K_ELSE", "K_ITERATE", "K_OPEN", 
                      "K_SAMPLEID", "K_USER", "K_CASESPECIFIC", "K_ELSEIF", 
                      "K_JOIN", "K_OPTION", "K_SCROLL", "K_USING", "K_CASE_N", 
                      "K_ENABLED", "K_JOURNAL", "K_OR", "K_SECOND", "K_VALUE", 
                      "K_CAST", "K_END", "K_KEY", "K_ORDER", "K_SEL", "K_VALUES", 
                      "K_CD", "K_EQ", "K_KURTOSIS", "K_OUT", "K_SELECT", 
                      "K_VARBYTE", "K_CHAR", "K_ERROR", "K_LANGUAGE", "K_OUTER", 
                      "K_SESSION", "K_VARCHAR", "K_CHAR2HEXINT", "K_ERRORFILES", 
                      "K_LE", "K_OVER", "K_SET", "K_VARGRAPHIC", "K_CHARACTER", 
                      "K_ERRORTABLES", "K_LEADING", "K_OVERLAPS", "K_SETRESRATE", 
                      "K_VARYING", "K_CHARACTERS", "K_ESCAPE", "K_LEAVE", 
                      "K_OVERRIDE", "K_SETSESSRATE", "K_VAR_POP", "K_CHARACTER_LENGTH", 
                      "K_ET", "K_LEFT", "K_PARAMETER", "K_SHOW", "K_VAR_SAMP", 
                      "K_CHARS", "K_EXCEPT", "K_LIKE", "K_PASSWORD", "K_SIMPLE", 
                      "K_VIEW", "K_CHAR_LENGTH", "K_EXEC", "K_LIMIT", "K_PERCENT", 
                      "K_SIN", "K_VOLATILE", "K_CHECK", "K_EXECUTE", "K_LN", 
                      "K_PERCENT_RANK", "K_SINH", "K_WAIT", "K_CHECKPOINT", 
                      "K_EXISTS", "K_LOADING", "K_PERM", "K_SKEW", "K_WHEN", 
                      "K_CLASS", "K_EXIT", "K_LOCAL", "K_PERMANENT", "K_SMALLINT", 
                      "K_WHERE", "K_CLOSE", "K_EXP", "K_LOCATOR", "K_POSITION", 
                      "K_SOME", "K_WHILE", "K_CLUSTER", "K_EXPLAIN", "K_LOCK", 
                      "K_PRECISION", "K_SOUNDEX", "K_WIDTH_BUCKET", "K_CM", 
                      "K_EXTERNAL", "K_LOCKING", "K_PREPARE", "K_SPECIFIC", 
                      "K_WITH", "K_COALESCE", "K_EXTRACT", "K_LOG", "K_PRESERVE", 
                      "K_SPOOL", "K_WITHOUT", "K_COLLATION", "K_FALLBACK", 
                      "K_LOGGING", "K_PRIMARY", "K_SQL", "K_WORK", "K_COLLECT", 
                      "K_FASTEXPORT", "K_LOGON", "K_PRIVATE", "K_SQLEXCEPTION", 
                      "K_YEAR", "K_COLUMN", "K_FETCH", "K_LONG", "K_PRIVILEGES", 
                      "K_SQLTEXT", "K_ZEROIFNULL", "K_COMMENT", "K_FIRST", 
                      "K_LOOP", "K_PROCEDURE", "K_SQLWARNING", "K_ZONE", 
                      "K_COMMIT", "K_FLOAT", "K_LOWER", "K_PROFILE", "K_SQRT", 
                      "K_COMPRESS", "K_FOR", "K_LT", "K_PROPORTIONAL", "K_SS", 
                      "K_CONSTRAINT", "K_FOREIGN", "K_MACRO", "K_PROTECTION", 
                      "K_START", "K_CONTINUE", "K_FORMAT", "K_MAVG", "K_PUBLIC", 
                      "K_STARTUP", "K_TOP", "K_TIES", "K_VALIDTIME", "K_TRANSACTIONTIME", 
                      "K_BIGINT", "K_NORMALIZE", "K_MEETS", "K_LAST", "K_NULLS", 
                      "K_ERRORS", "K_MATCHED", "K_PARTITION", "K_LTRIM", 
                      "K_RTRIM", "K_LPAD", "K_RPAD", "K_UNBOUNDED", "K_FOLLOWING", 
                      "K_PRECEDING", "K_CUME_DIST", "K_DENSE_RANK", "K_FIRST_VALUE", 
                      "K_LAST_VALUE", "K_MEDIAN", "K_PERCENTILE_CON", "K_PERCENTILE_DIS", 
                      "K_CEILING", "K_FLOOR", "K_POWER", "K_ROUND", "K_SIGN", 
                      "K_TRUNC", "K_DEGREESRADIANS", "K_NVL", "K_NVL2", 
                      "K_ASCII", "K_CHR", "K_CSVLD", "K_EDITDISTANCE", "K_INITCAP", 
                      "K_INSTR", "K_NGRAM", "K_NVP", "K_OREPLACE", "K_OTRANSLATE", 
                      "K_STRTOK", "K_STRTOK_SPLIT_TO_TABLE", "K_LENGTH", 
                      "K_CSV", "K_CURRENT_ROLE", "K_CURRENT_USER", "K_TEMPORAL_DATE", 
                      "K_TEMPORAL_TIMESTAMP", "K_BITAND", "K_BITNOT", "K_BITOR", 
                      "K_BITXOR", "K_COUNTSET", "K_GETBIT", "K_ROTATELEFT", 
                      "K_ROTATERIGHT", "K_SETBIT", "K_SHIFTLEFT", "K_SHIFTRIGHT", 
                      "K_SUBBITSTR", "K_TO_BYTE", "K_TO_CHAR", "K_TO_DATE", 
                      "K_TO_TIMESTAMP", "K_TO_NUMBER", "K_OADD_MONTHS", 
                      "K_GROUPING", "K_CEIL", "K_GREATEST", "K_LEAST", "K_LAST_DAY", 
                      "K_NEXT_DAY", "K_MONTHS_BETWEEN", "K_REVERSE", "K_TD_DAY_OF_WEEK", 
                      "K_TD_DAY_OF_MONTH", "K_TD_DAY_OF_YEAR", "K_TD_WEEK_OF_YEAR", 
                      "K_TD_MONTH_OF_QUARTER", "K_TD_MONTH_OF_YEAR", "K_TD_QUARTER_OF_YEAR", 
                      "NUMERIC_LITERAL", "INTEGER", "DECIMAL", "SCIENTIFIC", 
                      "IDENTIFIER", "STRING_LITERAL", "SINGLE_LINE_COMMENT", 
                      "MULTILINE_COMMENT", "SPACES", "UNEXPECTED_CHAR" ]

    RULE_start = 0
    RULE_sql_statement = 1
    RULE_select_statement = 2
    RULE_with_clause_select = 3
    RULE_select_expr = 4
    RULE_subquery = 5
    RULE_select_list = 6
    RULE_select_list_expr = 7
    RULE_field_mode_cast = 8
    RULE_case_specific = 9
    RULE_top_expr = 10
    RULE_format_expr = 11
    RULE_expr = 12
    RULE_expr_list = 13
    RULE_extract_expr = 14
    RULE_interval_expr = 15
    RULE_analytical_function_expr = 16
    RULE_partition_by_list = 17
    RULE_analytical_function_window = 18
    RULE_window_bound = 19
    RULE_from_clause = 20
    RULE_from_expr = 21
    RULE_from_table_expr = 22
    RULE_from_single_expr = 23
    RULE_from_derived_expr = 24
    RULE_from_join_expr = 25
    RULE_from_with_expr = 26
    RULE_where_clause = 27
    RULE_having_qualify_expr = 28
    RULE_having_expr = 29
    RULE_qualify_expr = 30
    RULE_group_by_list = 31
    RULE_group_by_val = 32
    RULE_order_by_list = 33
    RULE_order_by_val = 34
    RULE_ordinary_grouping_set = 35
    RULE_empty_grouping_set = 36
    RULE_insert_statement = 37
    RULE_insert_logging_errors = 38
    RULE_delete_statement = 39
    RULE_update_statement = 40
    RULE_update_set = 41
    RULE_merge_statement = 42
    RULE_merge_target = 43
    RULE_merge_source = 44
    RULE_merge_condition = 45
    RULE_merge_update = 46
    RULE_merge_insert = 47
    RULE_column_position = 48
    RULE_search_condition = 49
    RULE_conditional_expr = 50
    RULE_column_list = 51
    RULE_literal_value = 52
    RULE_unary_operator = 53
    RULE_set_operation = 54
    RULE_column_alias = 55
    RULE_query_name = 56
    RULE_expr_alias_name = 57
    RULE_derived_table_name = 58
    RULE_date_expr = 59
    RULE_timestamp_expr = 60
    RULE_time_expr = 61
    RULE_database_name = 62
    RULE_table_name = 63
    RULE_column_name = 64
    RULE_correlation_name = 65
    RULE_type_name = 66
    RULE_types = 67
    RULE_function_name = 68
    RULE_td_function_name = 69
    RULE_analytical_function_name = 70
    RULE_custom_function_name = 71

    ruleNames =  [ "start", "sql_statement", "select_statement", "with_clause_select", 
                   "select_expr", "subquery", "select_list", "select_list_expr", 
                   "field_mode_cast", "case_specific", "top_expr", "format_expr", 
                   "expr", "expr_list", "extract_expr", "interval_expr", 
                   "analytical_function_expr", "partition_by_list", "analytical_function_window", 
                   "window_bound", "from_clause", "from_expr", "from_table_expr", 
                   "from_single_expr", "from_derived_expr", "from_join_expr", 
                   "from_with_expr", "where_clause", "having_qualify_expr", 
                   "having_expr", "qualify_expr", "group_by_list", "group_by_val", 
                   "order_by_list", "order_by_val", "ordinary_grouping_set", 
                   "empty_grouping_set", "insert_statement", "insert_logging_errors", 
                   "delete_statement", "update_statement", "update_set", 
                   "merge_statement", "merge_target", "merge_source", "merge_condition", 
                   "merge_update", "merge_insert", "column_position", "search_condition", 
                   "conditional_expr", "column_list", "literal_value", "unary_operator", 
                   "set_operation", "column_alias", "query_name", "expr_alias_name", 
                   "derived_table_name", "date_expr", "timestamp_expr", 
                   "time_expr", "database_name", "table_name", "column_name", 
                   "correlation_name", "type_name", "types", "function_name", 
                   "td_function_name", "analytical_function_name", "custom_function_name" ]

    EOF = Token.EOF
    SCOL=1
    DOT=2
    OPEN_PAR=3
    CLOSE_PAR=4
    COMMA=5
    ASSIGN=6
    STAR=7
    PLUS=8
    MINUS=9
    TILDE=10
    PIPE2=11
    DIV=12
    MOD=13
    LT2=14
    GT2=15
    AMP=16
    PIPE=17
    LT=18
    LT_EQ=19
    GT=20
    GT_EQ=21
    EQ=22
    NOT_EQ1=23
    NOT_EQ2=24
    K_ABORT=25
    K_CONVERT_TABLE_HEADER=26
    K_FOUND=27
    K_MAX=28
    K_QUALIFIED=29
    K_STATEMENT=30
    K_ABORTSESSION=31
    K_CORR=32
    K_FREESPACE=33
    K_MAXIMUM=34
    K_QUALIFY=35
    K_STATISTICS=36
    K_ABS=37
    K_COS=38
    K_FROM=39
    K_MCHARACTERS=40
    K_QUANTILE=41
    K_STDDEV_POP=42
    K_ACCESS_LOCK=43
    K_COSH=44
    K_FULL=45
    K_MDIFF=46
    K_RADIANS=47
    K_STDDEV_SAMP=48
    K_ACCOUNT=49
    K_COUNT=50
    K_FUNCTION=51
    K_MERGE=52
    K_RANDOM=53
    K_STEPINFO=54
    K_ACOS=55
    K_COVAR_POP=56
    K_GE=57
    K_MIN=58
    K_RANGE_N=59
    K_STRING_CS=60
    K_ACOSH=61
    K_COVAR_SAMP=62
    K_GENERATED=63
    K_MINDEX=64
    K_RANK=65
    K_SUBSCRIBER=66
    K_ADD=67
    K_CREATE=68
    K_GIVE=69
    K_MINIMUM=70
    K_REAL=71
    K_SUBSTR=72
    K_ADD_MONTHS=73
    K_CROSS=74
    K_GO=75
    K_MINUS=76
    K_REFERENCES=77
    K_SUBSTRING=78
    K_ADMIN=79
    K_CS=80
    K_GOTO=81
    K_MINUTE=82
    K_REFERENCING=83
    K_SUM=84
    K_AFTER=85
    K_CSUM=86
    K_GRANT=87
    K_MLINREG=88
    K_REGR_AVGX=89
    K_SUMMARY=90
    K_AGGREGATE=91
    K_CT=92
    K_GRAPHIC=93
    K_MLOAD=94
    K_REGR_AVGY=95
    K_SUSPEND=96
    K_ALIAS=97
    K_CURRENT=98
    K_GROUP=99
    K_MOD=100
    K_REGR_COUNT=101
    K_TABLE=102
    K_ALL=103
    K_CURRENT_DATE=104
    K_GT=105
    K_MODE=106
    K_REGR_INTERCEPT=107
    K_TAN=108
    K_ALTER=109
    K_CURRENT_TIME=110
    K_HANDLER=111
    K_MODIFY=112
    K_REGR_R2=113
    K_TANH=114
    K_AMP=115
    K_CURRENT_TIMESTAMP=116
    K_HASH=117
    K_MONITOR=118
    K_REGR_SLOPE=119
    K_TBL_CS=120
    K_AND=121
    K_CURSOR=122
    K_HASHAMP=123
    K_MONRESOURCE=124
    K_REGR_SXX=125
    K_TEMPORARY=126
    K_ANSIDATE=127
    K_CV=128
    K_HASHBAKAMP=129
    K_MONSESSION=130
    K_REGR_SXY=131
    K_TERMINATE=132
    K_ANY=133
    K_CYCLE=134
    K_HASHBUCKET=135
    K_MONTH=136
    K_REGR_SYY=137
    K_THEN=138
    K_AS=139
    K_DATABASE=140
    K_HASHROW=141
    K_MSUBSTR=142
    K_RELEASE=143
    K_THRESHOLD=144
    K_ASC=145
    K_DATABLOCKSIZE=146
    K_HAVING=147
    K_MSUM=148
    K_RENAME=149
    K_TIME=150
    K_ASIN=151
    K_DATE=152
    K_HELP=153
    K_MULTISET=154
    K_REPEAT=155
    K_TIMESTAMP=156
    K_ASINH=157
    K_DATEFORM=158
    K_HOUR=159
    K_NAMED=160
    K_REPLACE=161
    K_TIMEZONE_HOUR=162
    K_AT=163
    K_DAY=164
    K_IDENTITY=165
    K_NATURAL=166
    K_REPLICATION=167
    K_TIMEZONE_MINUTE=168
    K_ATAN=169
    K_DEC=170
    K_IF=171
    K_NE=172
    K_REPOVERRIDE=173
    K_TITLE=174
    K_ATAN2=175
    K_DECIMAL=176
    K_IMMEDIATE=177
    K_NEW=178
    K_REQUEST=179
    K_TO=180
    K_ATANH=181
    K_DECLARE=182
    K_IN=183
    K_NEW_TABLE=184
    K_RESTART=185
    K_TRACE=186
    K_ATOMIC=187
    K_DEFAULT=188
    K_INCONSISTENT=189
    K_NEXT=190
    K_RESTORE=191
    K_TRAILING=192
    K_AUTHORIZATION=193
    K_DEGREES=194
    K_INDEX=195
    K_NO=196
    K_RESUME=197
    K_TRANSACTION=198
    K_AVE=199
    K_DEL=200
    K_INDICATOR=201
    K_NONE=202
    K_RET=203
    K_TRANSLATE=204
    K_AVERAGE=205
    K_DELETE=206
    K_INITIATE=207
    K_NOT=208
    K_RETRIEVE=209
    K_TRANSLATE_CHK=210
    K_AVG=211
    K_DESC=212
    K_INNER=213
    K_NOWAIT=214
    K_RETURNS=215
    K_TRIGGER=216
    K_BEFORE=217
    K_DESCRIPTOR=218
    K_INOUT=219
    K_NULL=220
    K_REVALIDATE=221
    K_TRIM=222
    K_BEGIN=223
    K_DETERMINISTIC=224
    K_INPUT=225
    K_NULLIF=226
    K_REVOKE=227
    K_TYPE=228
    K_BETWEEN=229
    K_DIAGNOSTIC=230
    K_INS=231
    K_NULLIFZERO=232
    K_RIGHT=233
    K_UC=234
    K_BLOB=235
    K_DISABLED=236
    K_INSERT=237
    K_NUMERIC=238
    K_RIGHTS=239
    K_UNDEFINED=240
    K_BOTH=241
    K_DISTINCT=242
    K_INSTEAD=243
    K_OBJECTS=244
    K_ROLE=245
    K_UNDO=246
    K_BT=247
    K_DO=248
    K_INT=249
    K_OCTET_LENGTH=250
    K_ROLLBACK=251
    K_UNION=252
    K_BUT=253
    K_DOUBLE=254
    K_INTEGER=255
    K_OF=256
    K_ROLLFORWARD=257
    K_UNIQUE=258
    K_BY=259
    K_DROP=260
    K_INTEGERDATE=261
    K_OFF=262
    K_ROW=263
    K_UNTIL=264
    K_BYTE=265
    K_DUAL=266
    K_INTERSECT=267
    K_OLD=268
    K_ROWID=269
    K_UPD=270
    K_BYTEINT=271
    K_DUMP=272
    K_INTERVAL=273
    K_OLD_TABLE=274
    K_ROWS=275
    K_UPDATE=276
    K_BYTES=277
    K_EACH=278
    K_INTO=279
    K_ON=280
    K_ROW_NUMBER=281
    K_UPPER=282
    K_CALL=283
    K_ECHO=284
    K_IS=285
    K_ONLY=286
    K_SAMPLE=287
    K_UPPERCASE=288
    K_CASE=289
    K_ELSE=290
    K_ITERATE=291
    K_OPEN=292
    K_SAMPLEID=293
    K_USER=294
    K_CASESPECIFIC=295
    K_ELSEIF=296
    K_JOIN=297
    K_OPTION=298
    K_SCROLL=299
    K_USING=300
    K_CASE_N=301
    K_ENABLED=302
    K_JOURNAL=303
    K_OR=304
    K_SECOND=305
    K_VALUE=306
    K_CAST=307
    K_END=308
    K_KEY=309
    K_ORDER=310
    K_SEL=311
    K_VALUES=312
    K_CD=313
    K_EQ=314
    K_KURTOSIS=315
    K_OUT=316
    K_SELECT=317
    K_VARBYTE=318
    K_CHAR=319
    K_ERROR=320
    K_LANGUAGE=321
    K_OUTER=322
    K_SESSION=323
    K_VARCHAR=324
    K_CHAR2HEXINT=325
    K_ERRORFILES=326
    K_LE=327
    K_OVER=328
    K_SET=329
    K_VARGRAPHIC=330
    K_CHARACTER=331
    K_ERRORTABLES=332
    K_LEADING=333
    K_OVERLAPS=334
    K_SETRESRATE=335
    K_VARYING=336
    K_CHARACTERS=337
    K_ESCAPE=338
    K_LEAVE=339
    K_OVERRIDE=340
    K_SETSESSRATE=341
    K_VAR_POP=342
    K_CHARACTER_LENGTH=343
    K_ET=344
    K_LEFT=345
    K_PARAMETER=346
    K_SHOW=347
    K_VAR_SAMP=348
    K_CHARS=349
    K_EXCEPT=350
    K_LIKE=351
    K_PASSWORD=352
    K_SIMPLE=353
    K_VIEW=354
    K_CHAR_LENGTH=355
    K_EXEC=356
    K_LIMIT=357
    K_PERCENT=358
    K_SIN=359
    K_VOLATILE=360
    K_CHECK=361
    K_EXECUTE=362
    K_LN=363
    K_PERCENT_RANK=364
    K_SINH=365
    K_WAIT=366
    K_CHECKPOINT=367
    K_EXISTS=368
    K_LOADING=369
    K_PERM=370
    K_SKEW=371
    K_WHEN=372
    K_CLASS=373
    K_EXIT=374
    K_LOCAL=375
    K_PERMANENT=376
    K_SMALLINT=377
    K_WHERE=378
    K_CLOSE=379
    K_EXP=380
    K_LOCATOR=381
    K_POSITION=382
    K_SOME=383
    K_WHILE=384
    K_CLUSTER=385
    K_EXPLAIN=386
    K_LOCK=387
    K_PRECISION=388
    K_SOUNDEX=389
    K_WIDTH_BUCKET=390
    K_CM=391
    K_EXTERNAL=392
    K_LOCKING=393
    K_PREPARE=394
    K_SPECIFIC=395
    K_WITH=396
    K_COALESCE=397
    K_EXTRACT=398
    K_LOG=399
    K_PRESERVE=400
    K_SPOOL=401
    K_WITHOUT=402
    K_COLLATION=403
    K_FALLBACK=404
    K_LOGGING=405
    K_PRIMARY=406
    K_SQL=407
    K_WORK=408
    K_COLLECT=409
    K_FASTEXPORT=410
    K_LOGON=411
    K_PRIVATE=412
    K_SQLEXCEPTION=413
    K_YEAR=414
    K_COLUMN=415
    K_FETCH=416
    K_LONG=417
    K_PRIVILEGES=418
    K_SQLTEXT=419
    K_ZEROIFNULL=420
    K_COMMENT=421
    K_FIRST=422
    K_LOOP=423
    K_PROCEDURE=424
    K_SQLWARNING=425
    K_ZONE=426
    K_COMMIT=427
    K_FLOAT=428
    K_LOWER=429
    K_PROFILE=430
    K_SQRT=431
    K_COMPRESS=432
    K_FOR=433
    K_LT=434
    K_PROPORTIONAL=435
    K_SS=436
    K_CONSTRAINT=437
    K_FOREIGN=438
    K_MACRO=439
    K_PROTECTION=440
    K_START=441
    K_CONTINUE=442
    K_FORMAT=443
    K_MAVG=444
    K_PUBLIC=445
    K_STARTUP=446
    K_TOP=447
    K_TIES=448
    K_VALIDTIME=449
    K_TRANSACTIONTIME=450
    K_BIGINT=451
    K_NORMALIZE=452
    K_MEETS=453
    K_LAST=454
    K_NULLS=455
    K_ERRORS=456
    K_MATCHED=457
    K_PARTITION=458
    K_LTRIM=459
    K_RTRIM=460
    K_LPAD=461
    K_RPAD=462
    K_UNBOUNDED=463
    K_FOLLOWING=464
    K_PRECEDING=465
    K_CUME_DIST=466
    K_DENSE_RANK=467
    K_FIRST_VALUE=468
    K_LAST_VALUE=469
    K_MEDIAN=470
    K_PERCENTILE_CON=471
    K_PERCENTILE_DIS=472
    K_CEILING=473
    K_FLOOR=474
    K_POWER=475
    K_ROUND=476
    K_SIGN=477
    K_TRUNC=478
    K_DEGREESRADIANS=479
    K_NVL=480
    K_NVL2=481
    K_ASCII=482
    K_CHR=483
    K_CSVLD=484
    K_EDITDISTANCE=485
    K_INITCAP=486
    K_INSTR=487
    K_NGRAM=488
    K_NVP=489
    K_OREPLACE=490
    K_OTRANSLATE=491
    K_STRTOK=492
    K_STRTOK_SPLIT_TO_TABLE=493
    K_LENGTH=494
    K_CSV=495
    K_CURRENT_ROLE=496
    K_CURRENT_USER=497
    K_TEMPORAL_DATE=498
    K_TEMPORAL_TIMESTAMP=499
    K_BITAND=500
    K_BITNOT=501
    K_BITOR=502
    K_BITXOR=503
    K_COUNTSET=504
    K_GETBIT=505
    K_ROTATELEFT=506
    K_ROTATERIGHT=507
    K_SETBIT=508
    K_SHIFTLEFT=509
    K_SHIFTRIGHT=510
    K_SUBBITSTR=511
    K_TO_BYTE=512
    K_TO_CHAR=513
    K_TO_DATE=514
    K_TO_TIMESTAMP=515
    K_TO_NUMBER=516
    K_OADD_MONTHS=517
    K_GROUPING=518
    K_CEIL=519
    K_GREATEST=520
    K_LEAST=521
    K_LAST_DAY=522
    K_NEXT_DAY=523
    K_MONTHS_BETWEEN=524
    K_REVERSE=525
    K_TD_DAY_OF_WEEK=526
    K_TD_DAY_OF_MONTH=527
    K_TD_DAY_OF_YEAR=528
    K_TD_WEEK_OF_YEAR=529
    K_TD_MONTH_OF_QUARTER=530
    K_TD_MONTH_OF_YEAR=531
    K_TD_QUARTER_OF_YEAR=532
    NUMERIC_LITERAL=533
    INTEGER=534
    DECIMAL=535
    SCIENTIFIC=536
    IDENTIFIER=537
    STRING_LITERAL=538
    SINGLE_LINE_COMMENT=539
    MULTILINE_COMMENT=540
    SPACES=541
    UNEXPECTED_CHAR=542

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sql_statement(self):
            return self.getTypedRuleContext(TDantlrParser.Sql_statementContext,0)


        def EOF(self):
            return self.getToken(TDantlrParser.EOF, 0)

        def SCOL(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.SCOL)
            else:
                return self.getToken(TDantlrParser.SCOL, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = TDantlrParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self.sql_statement()
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TDantlrParser.SCOL:
                self.state = 145
                self.match(TDantlrParser.SCOL)
                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 151
            self.match(TDantlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sql_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_statement(self):
            return self.getTypedRuleContext(TDantlrParser.Select_statementContext,0)


        def insert_statement(self):
            return self.getTypedRuleContext(TDantlrParser.Insert_statementContext,0)


        def delete_statement(self):
            return self.getTypedRuleContext(TDantlrParser.Delete_statementContext,0)


        def update_statement(self):
            return self.getTypedRuleContext(TDantlrParser.Update_statementContext,0)


        def merge_statement(self):
            return self.getTypedRuleContext(TDantlrParser.Merge_statementContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_sql_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSql_statement" ):
                listener.enterSql_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSql_statement" ):
                listener.exitSql_statement(self)




    def sql_statement(self):

        localctx = TDantlrParser.Sql_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sql_statement)
        try:
            self.state = 158
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.K_SEL, TDantlrParser.K_SELECT, TDantlrParser.K_WITH]:
                self.enterOuterAlt(localctx, 1)
                self.state = 153
                self.select_statement()
                pass
            elif token in [TDantlrParser.K_INS, TDantlrParser.K_INSERT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 154
                self.insert_statement()
                pass
            elif token in [TDantlrParser.K_DEL, TDantlrParser.K_DELETE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 155
                self.delete_statement()
                pass
            elif token in [TDantlrParser.K_UPD, TDantlrParser.K_UPDATE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 156
                self.update_statement()
                pass
            elif token in [TDantlrParser.K_MERGE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 157
                self.merge_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Select_exprContext,0)


        def with_clause_select(self):
            return self.getTypedRuleContext(TDantlrParser.With_clause_selectContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_select_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_statement" ):
                listener.enterSelect_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_statement" ):
                listener.exitSelect_statement(self)




    def select_statement(self):

        localctx = TDantlrParser.Select_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_select_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_WITH:
                self.state = 160
                self.with_clause_select()


            self.state = 163
            self.select_expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class With_clause_selectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WITH(self):
            return self.getToken(TDantlrParser.K_WITH, 0)

        def query_name(self):
            return self.getTypedRuleContext(TDantlrParser.Query_nameContext,0)


        def K_AS(self):
            return self.getToken(TDantlrParser.K_AS, 0)

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.OPEN_PAR)
            else:
                return self.getToken(TDantlrParser.OPEN_PAR, i)

        def select_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Select_exprContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.CLOSE_PAR)
            else:
                return self.getToken(TDantlrParser.CLOSE_PAR, i)

        def column_list(self):
            return self.getTypedRuleContext(TDantlrParser.Column_listContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_with_clause_select

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWith_clause_select" ):
                listener.enterWith_clause_select(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWith_clause_select" ):
                listener.exitWith_clause_select(self)




    def with_clause_select(self):

        localctx = TDantlrParser.With_clause_selectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_with_clause_select)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.match(TDantlrParser.K_WITH)
            self.state = 166
            self.query_name()
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.OPEN_PAR:
                self.state = 167
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 168
                self.column_list()
                self.state = 169
                self.match(TDantlrParser.CLOSE_PAR)


            self.state = 173
            self.match(TDantlrParser.K_AS)
            self.state = 174
            self.match(TDantlrParser.OPEN_PAR)
            self.state = 175
            self.select_expr(0)
            self.state = 176
            self.match(TDantlrParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_list(self):
            return self.getTypedRuleContext(TDantlrParser.Select_listContext,0)


        def K_SELECT(self):
            return self.getToken(TDantlrParser.K_SELECT, 0)

        def K_SEL(self):
            return self.getToken(TDantlrParser.K_SEL, 0)

        def top_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Top_exprContext,0)


        def from_clause(self):
            return self.getTypedRuleContext(TDantlrParser.From_clauseContext,0)


        def from_with_expr(self):
            return self.getTypedRuleContext(TDantlrParser.From_with_exprContext,0)


        def where_clause(self):
            return self.getTypedRuleContext(TDantlrParser.Where_clauseContext,0)


        def K_GROUP(self):
            return self.getToken(TDantlrParser.K_GROUP, 0)

        def K_BY(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_BY)
            else:
                return self.getToken(TDantlrParser.K_BY, i)

        def group_by_list(self):
            return self.getTypedRuleContext(TDantlrParser.Group_by_listContext,0)


        def having_qualify_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Having_qualify_exprContext,0)


        def K_ORDER(self):
            return self.getToken(TDantlrParser.K_ORDER, 0)

        def order_by_list(self):
            return self.getTypedRuleContext(TDantlrParser.Order_by_listContext,0)


        def K_DISTINCT(self):
            return self.getToken(TDantlrParser.K_DISTINCT, 0)

        def K_ALL(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_ALL)
            else:
                return self.getToken(TDantlrParser.K_ALL, i)

        def K_NULLS(self):
            return self.getToken(TDantlrParser.K_NULLS, 0)

        def K_FIRST(self):
            return self.getToken(TDantlrParser.K_FIRST, 0)

        def K_LAST(self):
            return self.getToken(TDantlrParser.K_LAST, 0)

        def K_ASC(self):
            return self.getToken(TDantlrParser.K_ASC, 0)

        def K_DESC(self):
            return self.getToken(TDantlrParser.K_DESC, 0)

        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.DOT)
            else:
                return self.getToken(TDantlrParser.DOT, i)

        def STAR(self):
            return self.getToken(TDantlrParser.STAR, 0)

        def column_name(self):
            return self.getTypedRuleContext(TDantlrParser.Column_nameContext,0)


        def select_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.Select_exprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.Select_exprContext,i)


        def set_operation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.Set_operationContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.Set_operationContext,i)


        def getRuleIndex(self):
            return TDantlrParser.RULE_select_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_expr" ):
                listener.enterSelect_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_expr" ):
                listener.exitSelect_expr(self)



    def select_expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TDantlrParser.Select_exprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 8
        self.enterRecursionRule(localctx, 8, self.RULE_select_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            _la = self._input.LA(1)
            if not(_la==TDantlrParser.K_SEL or _la==TDantlrParser.K_SELECT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 194
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.K_ALL, TDantlrParser.K_DISTINCT]:
                self.state = 180
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_ALL or _la==TDantlrParser.K_DISTINCT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 191
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                if la_ == 1:
                    self.state = 181
                    self.table_name()
                    self.state = 182
                    self.match(TDantlrParser.DOT)
                    self.state = 183
                    self.match(TDantlrParser.STAR)
                    self.state = 184
                    self.match(TDantlrParser.DOT)
                    self.state = 185
                    self.match(TDantlrParser.K_ALL)

                elif la_ == 2:
                    self.state = 187
                    self.column_name()
                    self.state = 188
                    self.match(TDantlrParser.DOT)
                    self.state = 189
                    self.match(TDantlrParser.K_ALL)


                pass
            elif token in [TDantlrParser.K_TOP]:
                self.state = 193
                self.top_expr()
                pass
            elif token in [TDantlrParser.OPEN_PAR, TDantlrParser.STAR, TDantlrParser.PLUS, TDantlrParser.MINUS, TDantlrParser.TILDE, TDantlrParser.K_MAX, TDantlrParser.K_CORR, TDantlrParser.K_MAXIMUM, TDantlrParser.K_ABS, TDantlrParser.K_COS, TDantlrParser.K_QUANTILE, TDantlrParser.K_STDDEV_POP, TDantlrParser.K_COSH, TDantlrParser.K_MDIFF, TDantlrParser.K_RADIANS, TDantlrParser.K_STDDEV_SAMP, TDantlrParser.K_ACCOUNT, TDantlrParser.K_COUNT, TDantlrParser.K_RANDOM, TDantlrParser.K_ACOS, TDantlrParser.K_COVAR_POP, TDantlrParser.K_MIN, TDantlrParser.K_RANGE_N, TDantlrParser.K_STRING_CS, TDantlrParser.K_ACOSH, TDantlrParser.K_COVAR_SAMP, TDantlrParser.K_RANK, TDantlrParser.K_MINIMUM, TDantlrParser.K_SUBSTR, TDantlrParser.K_ADD_MONTHS, TDantlrParser.K_SUBSTRING, TDantlrParser.K_MINUTE, TDantlrParser.K_SUM, TDantlrParser.K_CSUM, TDantlrParser.K_MLINREG, TDantlrParser.K_REGR_AVGX, TDantlrParser.K_REGR_AVGY, TDantlrParser.K_MOD, TDantlrParser.K_REGR_COUNT, TDantlrParser.K_CURRENT_DATE, TDantlrParser.K_REGR_INTERCEPT, TDantlrParser.K_TAN, TDantlrParser.K_CURRENT_TIME, TDantlrParser.K_REGR_R2, TDantlrParser.K_TANH, TDantlrParser.K_CURRENT_TIMESTAMP, TDantlrParser.K_REGR_SLOPE, TDantlrParser.K_REGR_SXX, TDantlrParser.K_REGR_SXY, TDantlrParser.K_MONTH, TDantlrParser.K_REGR_SYY, TDantlrParser.K_DATABASE, TDantlrParser.K_MSUM, TDantlrParser.K_TIME, TDantlrParser.K_ASIN, TDantlrParser.K_DATE, TDantlrParser.K_TIMESTAMP, TDantlrParser.K_ASINH, TDantlrParser.K_HOUR, TDantlrParser.K_TIMEZONE_HOUR, TDantlrParser.K_DAY, TDantlrParser.K_TIMEZONE_MINUTE, TDantlrParser.K_ATAN, TDantlrParser.K_TITLE, TDantlrParser.K_ATAN2, TDantlrParser.K_ATANH, TDantlrParser.K_DEFAULT, TDantlrParser.K_DEGREES, TDantlrParser.K_INDEX, TDantlrParser.K_TRANSLATE, TDantlrParser.K_NOT, TDantlrParser.K_TRANSLATE_CHK, TDantlrParser.K_AVG, TDantlrParser.K_NULL, TDantlrParser.K_TRIM, TDantlrParser.K_NULLIF, TDantlrParser.K_TYPE, TDantlrParser.K_NULLIFZERO, TDantlrParser.K_RIGHT, TDantlrParser.K_ROLE, TDantlrParser.K_OCTET_LENGTH, TDantlrParser.K_BYTE, TDantlrParser.K_INTERVAL, TDantlrParser.K_BYTES, TDantlrParser.K_ROW_NUMBER, TDantlrParser.K_UPPER, TDantlrParser.K_CASE, TDantlrParser.K_USER, TDantlrParser.K_CASE_N, TDantlrParser.K_SECOND, TDantlrParser.K_CAST, TDantlrParser.K_KURTOSIS, TDantlrParser.K_CHAR, TDantlrParser.K_SESSION, TDantlrParser.K_CHAR2HEXINT, TDantlrParser.K_VARGRAPHIC, TDantlrParser.K_CHARACTERS, TDantlrParser.K_VAR_POP, TDantlrParser.K_CHARACTER_LENGTH, TDantlrParser.K_LEFT, TDantlrParser.K_VAR_SAMP, TDantlrParser.K_CHARS, TDantlrParser.K_CHAR_LENGTH, TDantlrParser.K_SIN, TDantlrParser.K_LN, TDantlrParser.K_PERCENT_RANK, TDantlrParser.K_SINH, TDantlrParser.K_EXISTS, TDantlrParser.K_SKEW, TDantlrParser.K_EXP, TDantlrParser.K_POSITION, TDantlrParser.K_SOUNDEX, TDantlrParser.K_WIDTH_BUCKET, TDantlrParser.K_COALESCE, TDantlrParser.K_EXTRACT, TDantlrParser.K_LOG, TDantlrParser.K_YEAR, TDantlrParser.K_ZEROIFNULL, TDantlrParser.K_LOWER, TDantlrParser.K_PROFILE, TDantlrParser.K_SQRT, TDantlrParser.K_FORMAT, TDantlrParser.K_MAVG, TDantlrParser.K_LTRIM, TDantlrParser.K_RTRIM, TDantlrParser.K_LPAD, TDantlrParser.K_RPAD, TDantlrParser.K_CUME_DIST, TDantlrParser.K_DENSE_RANK, TDantlrParser.K_FIRST_VALUE, TDantlrParser.K_LAST_VALUE, TDantlrParser.K_MEDIAN, TDantlrParser.K_PERCENTILE_CON, TDantlrParser.K_PERCENTILE_DIS, TDantlrParser.K_CEILING, TDantlrParser.K_FLOOR, TDantlrParser.K_POWER, TDantlrParser.K_ROUND, TDantlrParser.K_SIGN, TDantlrParser.K_TRUNC, TDantlrParser.K_DEGREESRADIANS, TDantlrParser.K_NVL, TDantlrParser.K_NVL2, TDantlrParser.K_ASCII, TDantlrParser.K_CHR, TDantlrParser.K_CSVLD, TDantlrParser.K_EDITDISTANCE, TDantlrParser.K_INITCAP, TDantlrParser.K_INSTR, TDantlrParser.K_NGRAM, TDantlrParser.K_NVP, TDantlrParser.K_OREPLACE, TDantlrParser.K_OTRANSLATE, TDantlrParser.K_STRTOK, TDantlrParser.K_STRTOK_SPLIT_TO_TABLE, TDantlrParser.K_LENGTH, TDantlrParser.K_CSV, TDantlrParser.K_CURRENT_ROLE, TDantlrParser.K_CURRENT_USER, TDantlrParser.K_TEMPORAL_DATE, TDantlrParser.K_TEMPORAL_TIMESTAMP, TDantlrParser.K_BITAND, TDantlrParser.K_BITNOT, TDantlrParser.K_BITOR, TDantlrParser.K_BITXOR, TDantlrParser.K_COUNTSET, TDantlrParser.K_GETBIT, TDantlrParser.K_ROTATELEFT, TDantlrParser.K_ROTATERIGHT, TDantlrParser.K_SETBIT, TDantlrParser.K_SHIFTLEFT, TDantlrParser.K_SHIFTRIGHT, TDantlrParser.K_SUBBITSTR, TDantlrParser.K_TO_BYTE, TDantlrParser.K_TO_CHAR, TDantlrParser.K_TO_DATE, TDantlrParser.K_TO_TIMESTAMP, TDantlrParser.K_TO_NUMBER, TDantlrParser.K_OADD_MONTHS, TDantlrParser.K_GROUPING, TDantlrParser.K_CEIL, TDantlrParser.K_GREATEST, TDantlrParser.K_LEAST, TDantlrParser.K_LAST_DAY, TDantlrParser.K_NEXT_DAY, TDantlrParser.K_MONTHS_BETWEEN, TDantlrParser.K_REVERSE, TDantlrParser.K_TD_DAY_OF_WEEK, TDantlrParser.K_TD_DAY_OF_MONTH, TDantlrParser.K_TD_DAY_OF_YEAR, TDantlrParser.K_TD_WEEK_OF_YEAR, TDantlrParser.K_TD_MONTH_OF_QUARTER, TDantlrParser.K_TD_MONTH_OF_YEAR, TDantlrParser.K_TD_QUARTER_OF_YEAR, TDantlrParser.NUMERIC_LITERAL, TDantlrParser.IDENTIFIER, TDantlrParser.STRING_LITERAL]:
                pass
            else:
                pass
            self.state = 196
            self.select_list()
            self.state = 198
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.state = 197
                self.from_clause()


            self.state = 201
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 200
                self.from_with_expr()


            self.state = 204
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 203
                self.where_clause()


            self.state = 209
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.state = 206
                self.match(TDantlrParser.K_GROUP)
                self.state = 207
                self.match(TDantlrParser.K_BY)
                self.state = 208
                self.group_by_list()


            self.state = 212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.state = 211
                self.having_qualify_expr()


            self.state = 226
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.state = 214
                self.match(TDantlrParser.K_ORDER)
                self.state = 215
                self.match(TDantlrParser.K_BY)
                self.state = 216
                self.order_by_list()
                self.state = 218
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
                if la_ == 1:
                    self.state = 217
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 224
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                if la_ == 1:
                    self.state = 220
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 221
                    self.match(TDantlrParser.K_FIRST)

                elif la_ == 2:
                    self.state = 222
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 223
                    self.match(TDantlrParser.K_LAST)




            self._ctx.stop = self._input.LT(-1)
            self.state = 238
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TDantlrParser.Select_exprContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_select_expr)
                    self.state = 228
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 232 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 229
                            self.set_operation()
                            self.state = 230
                            self.select_expr(0)

                        else:
                            raise NoViableAltException(self)
                        self.state = 234 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
             
                self.state = 240
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class SubqueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Select_exprContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_subquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubquery" ):
                listener.enterSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubquery" ):
                listener.exitSubquery(self)




    def subquery(self):

        localctx = TDantlrParser.SubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_subquery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.select_expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(TDantlrParser.STAR, 0)

        def select_list_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.Select_list_exprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.Select_list_exprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_select_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_list" ):
                listener.enterSelect_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_list" ):
                listener.exitSelect_list(self)




    def select_list(self):

        localctx = TDantlrParser.Select_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_select_list)
        try:
            self.state = 252
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.STAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 243
                self.match(TDantlrParser.STAR)
                pass
            elif token in [TDantlrParser.OPEN_PAR, TDantlrParser.PLUS, TDantlrParser.MINUS, TDantlrParser.TILDE, TDantlrParser.K_MAX, TDantlrParser.K_CORR, TDantlrParser.K_MAXIMUM, TDantlrParser.K_ABS, TDantlrParser.K_COS, TDantlrParser.K_QUANTILE, TDantlrParser.K_STDDEV_POP, TDantlrParser.K_COSH, TDantlrParser.K_MDIFF, TDantlrParser.K_RADIANS, TDantlrParser.K_STDDEV_SAMP, TDantlrParser.K_ACCOUNT, TDantlrParser.K_COUNT, TDantlrParser.K_RANDOM, TDantlrParser.K_ACOS, TDantlrParser.K_COVAR_POP, TDantlrParser.K_MIN, TDantlrParser.K_RANGE_N, TDantlrParser.K_STRING_CS, TDantlrParser.K_ACOSH, TDantlrParser.K_COVAR_SAMP, TDantlrParser.K_RANK, TDantlrParser.K_MINIMUM, TDantlrParser.K_SUBSTR, TDantlrParser.K_ADD_MONTHS, TDantlrParser.K_SUBSTRING, TDantlrParser.K_MINUTE, TDantlrParser.K_SUM, TDantlrParser.K_CSUM, TDantlrParser.K_MLINREG, TDantlrParser.K_REGR_AVGX, TDantlrParser.K_REGR_AVGY, TDantlrParser.K_MOD, TDantlrParser.K_REGR_COUNT, TDantlrParser.K_CURRENT_DATE, TDantlrParser.K_REGR_INTERCEPT, TDantlrParser.K_TAN, TDantlrParser.K_CURRENT_TIME, TDantlrParser.K_REGR_R2, TDantlrParser.K_TANH, TDantlrParser.K_CURRENT_TIMESTAMP, TDantlrParser.K_REGR_SLOPE, TDantlrParser.K_REGR_SXX, TDantlrParser.K_REGR_SXY, TDantlrParser.K_MONTH, TDantlrParser.K_REGR_SYY, TDantlrParser.K_DATABASE, TDantlrParser.K_MSUM, TDantlrParser.K_TIME, TDantlrParser.K_ASIN, TDantlrParser.K_DATE, TDantlrParser.K_TIMESTAMP, TDantlrParser.K_ASINH, TDantlrParser.K_HOUR, TDantlrParser.K_TIMEZONE_HOUR, TDantlrParser.K_DAY, TDantlrParser.K_TIMEZONE_MINUTE, TDantlrParser.K_ATAN, TDantlrParser.K_TITLE, TDantlrParser.K_ATAN2, TDantlrParser.K_ATANH, TDantlrParser.K_DEFAULT, TDantlrParser.K_DEGREES, TDantlrParser.K_INDEX, TDantlrParser.K_TRANSLATE, TDantlrParser.K_NOT, TDantlrParser.K_TRANSLATE_CHK, TDantlrParser.K_AVG, TDantlrParser.K_NULL, TDantlrParser.K_TRIM, TDantlrParser.K_NULLIF, TDantlrParser.K_TYPE, TDantlrParser.K_NULLIFZERO, TDantlrParser.K_RIGHT, TDantlrParser.K_ROLE, TDantlrParser.K_OCTET_LENGTH, TDantlrParser.K_BYTE, TDantlrParser.K_INTERVAL, TDantlrParser.K_BYTES, TDantlrParser.K_ROW_NUMBER, TDantlrParser.K_UPPER, TDantlrParser.K_CASE, TDantlrParser.K_USER, TDantlrParser.K_CASE_N, TDantlrParser.K_SECOND, TDantlrParser.K_CAST, TDantlrParser.K_KURTOSIS, TDantlrParser.K_CHAR, TDantlrParser.K_SESSION, TDantlrParser.K_CHAR2HEXINT, TDantlrParser.K_VARGRAPHIC, TDantlrParser.K_CHARACTERS, TDantlrParser.K_VAR_POP, TDantlrParser.K_CHARACTER_LENGTH, TDantlrParser.K_LEFT, TDantlrParser.K_VAR_SAMP, TDantlrParser.K_CHARS, TDantlrParser.K_CHAR_LENGTH, TDantlrParser.K_SIN, TDantlrParser.K_LN, TDantlrParser.K_PERCENT_RANK, TDantlrParser.K_SINH, TDantlrParser.K_EXISTS, TDantlrParser.K_SKEW, TDantlrParser.K_EXP, TDantlrParser.K_POSITION, TDantlrParser.K_SOUNDEX, TDantlrParser.K_WIDTH_BUCKET, TDantlrParser.K_COALESCE, TDantlrParser.K_EXTRACT, TDantlrParser.K_LOG, TDantlrParser.K_YEAR, TDantlrParser.K_ZEROIFNULL, TDantlrParser.K_LOWER, TDantlrParser.K_PROFILE, TDantlrParser.K_SQRT, TDantlrParser.K_FORMAT, TDantlrParser.K_MAVG, TDantlrParser.K_LTRIM, TDantlrParser.K_RTRIM, TDantlrParser.K_LPAD, TDantlrParser.K_RPAD, TDantlrParser.K_CUME_DIST, TDantlrParser.K_DENSE_RANK, TDantlrParser.K_FIRST_VALUE, TDantlrParser.K_LAST_VALUE, TDantlrParser.K_MEDIAN, TDantlrParser.K_PERCENTILE_CON, TDantlrParser.K_PERCENTILE_DIS, TDantlrParser.K_CEILING, TDantlrParser.K_FLOOR, TDantlrParser.K_POWER, TDantlrParser.K_ROUND, TDantlrParser.K_SIGN, TDantlrParser.K_TRUNC, TDantlrParser.K_DEGREESRADIANS, TDantlrParser.K_NVL, TDantlrParser.K_NVL2, TDantlrParser.K_ASCII, TDantlrParser.K_CHR, TDantlrParser.K_CSVLD, TDantlrParser.K_EDITDISTANCE, TDantlrParser.K_INITCAP, TDantlrParser.K_INSTR, TDantlrParser.K_NGRAM, TDantlrParser.K_NVP, TDantlrParser.K_OREPLACE, TDantlrParser.K_OTRANSLATE, TDantlrParser.K_STRTOK, TDantlrParser.K_STRTOK_SPLIT_TO_TABLE, TDantlrParser.K_LENGTH, TDantlrParser.K_CSV, TDantlrParser.K_CURRENT_ROLE, TDantlrParser.K_CURRENT_USER, TDantlrParser.K_TEMPORAL_DATE, TDantlrParser.K_TEMPORAL_TIMESTAMP, TDantlrParser.K_BITAND, TDantlrParser.K_BITNOT, TDantlrParser.K_BITOR, TDantlrParser.K_BITXOR, TDantlrParser.K_COUNTSET, TDantlrParser.K_GETBIT, TDantlrParser.K_ROTATELEFT, TDantlrParser.K_ROTATERIGHT, TDantlrParser.K_SETBIT, TDantlrParser.K_SHIFTLEFT, TDantlrParser.K_SHIFTRIGHT, TDantlrParser.K_SUBBITSTR, TDantlrParser.K_TO_BYTE, TDantlrParser.K_TO_CHAR, TDantlrParser.K_TO_DATE, TDantlrParser.K_TO_TIMESTAMP, TDantlrParser.K_TO_NUMBER, TDantlrParser.K_OADD_MONTHS, TDantlrParser.K_GROUPING, TDantlrParser.K_CEIL, TDantlrParser.K_GREATEST, TDantlrParser.K_LEAST, TDantlrParser.K_LAST_DAY, TDantlrParser.K_NEXT_DAY, TDantlrParser.K_MONTHS_BETWEEN, TDantlrParser.K_REVERSE, TDantlrParser.K_TD_DAY_OF_WEEK, TDantlrParser.K_TD_DAY_OF_MONTH, TDantlrParser.K_TD_DAY_OF_YEAR, TDantlrParser.K_TD_WEEK_OF_YEAR, TDantlrParser.K_TD_MONTH_OF_QUARTER, TDantlrParser.K_TD_MONTH_OF_YEAR, TDantlrParser.K_TD_QUARTER_OF_YEAR, TDantlrParser.NUMERIC_LITERAL, TDantlrParser.IDENTIFIER, TDantlrParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 244
                self.select_list_expr()
                self.state = 249
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 245
                        self.match(TDantlrParser.COMMA)
                        self.state = 246
                        self.select_list_expr() 
                    self.state = 251
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_list_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)


        def expr_alias_name(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_alias_nameContext,0)


        def K_AS(self):
            return self.getToken(TDantlrParser.K_AS, 0)

        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def DOT(self):
            return self.getToken(TDantlrParser.DOT, 0)

        def STAR(self):
            return self.getToken(TDantlrParser.STAR, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_select_list_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_list_expr" ):
                listener.enterSelect_list_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_list_expr" ):
                listener.exitSelect_list_expr(self)




    def select_list_expr(self):

        localctx = TDantlrParser.Select_list_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_select_list_expr)
        self._la = 0 # Token type
        try:
            self.state = 265
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 254
                self.expr(0)
                self.state = 259
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
                if la_ == 1:
                    self.state = 256
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==TDantlrParser.K_AS:
                        self.state = 255
                        self.match(TDantlrParser.K_AS)


                    self.state = 258
                    self.expr_alias_name()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 261
                self.table_name()
                self.state = 262
                self.match(TDantlrParser.DOT)
                self.state = 263
                self.match(TDantlrParser.STAR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Field_mode_castContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)

        def type_name(self):
            return self.getTypedRuleContext(TDantlrParser.Type_nameContext,0)


        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_field_mode_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterField_mode_cast" ):
                listener.enterField_mode_cast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitField_mode_cast" ):
                listener.exitField_mode_cast(self)




    def field_mode_cast(self):

        localctx = TDantlrParser.Field_mode_castContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_field_mode_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 267
            self.match(TDantlrParser.OPEN_PAR)
            self.state = 268
            self.type_name()
            self.state = 269
            self.match(TDantlrParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_specificContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CASESPECIFIC(self):
            return self.getToken(TDantlrParser.K_CASESPECIFIC, 0)

        def K_CS(self):
            return self.getToken(TDantlrParser.K_CS, 0)

        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)

        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)

        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)

        def K_UPPERCASE(self):
            return self.getToken(TDantlrParser.K_UPPERCASE, 0)

        def K_UC(self):
            return self.getToken(TDantlrParser.K_UC, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_case_specific

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCase_specific" ):
                listener.enterCase_specific(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCase_specific" ):
                listener.exitCase_specific(self)




    def case_specific(self):

        localctx = TDantlrParser.Case_specificContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_case_specific)
        self._la = 0 # Token type
        try:
            self.state = 291
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 272
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.OPEN_PAR:
                    self.state = 271
                    self.match(TDantlrParser.OPEN_PAR)


                self.state = 275
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_NOT:
                    self.state = 274
                    self.match(TDantlrParser.K_NOT)


                self.state = 277
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_CS or _la==TDantlrParser.K_CASESPECIFIC):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 279
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
                if la_ == 1:
                    self.state = 278
                    self.match(TDantlrParser.CLOSE_PAR)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.OPEN_PAR:
                    self.state = 281
                    self.match(TDantlrParser.OPEN_PAR)


                self.state = 285
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_NOT:
                    self.state = 284
                    self.match(TDantlrParser.K_NOT)


                self.state = 287
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_UC or _la==TDantlrParser.K_UPPERCASE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 289
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
                if la_ == 1:
                    self.state = 288
                    self.match(TDantlrParser.CLOSE_PAR)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Top_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TOP(self):
            return self.getToken(TDantlrParser.K_TOP, 0)

        def INTEGER(self):
            return self.getToken(TDantlrParser.INTEGER, 0)

        def DECIMAL(self):
            return self.getToken(TDantlrParser.DECIMAL, 0)

        def K_PERCENT(self):
            return self.getToken(TDantlrParser.K_PERCENT, 0)

        def K_WITH(self):
            return self.getToken(TDantlrParser.K_WITH, 0)

        def K_TIES(self):
            return self.getToken(TDantlrParser.K_TIES, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_top_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTop_expr" ):
                listener.enterTop_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTop_expr" ):
                listener.exitTop_expr(self)




    def top_expr(self):

        localctx = TDantlrParser.Top_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_top_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.match(TDantlrParser.K_TOP)
            self.state = 294
            _la = self._input.LA(1)
            if not(_la==TDantlrParser.INTEGER or _la==TDantlrParser.DECIMAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 296
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_PERCENT:
                self.state = 295
                self.match(TDantlrParser.K_PERCENT)


            self.state = 300
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_WITH:
                self.state = 298
                self.match(TDantlrParser.K_WITH)
                self.state = 299
                self.match(TDantlrParser.K_TIES)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Format_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FORMAT(self):
            return self.getToken(TDantlrParser.K_FORMAT, 0)

        def STRING_LITERAL(self):
            return self.getToken(TDantlrParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_format_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormat_expr" ):
                listener.enterFormat_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormat_expr" ):
                listener.exitFormat_expr(self)




    def format_expr(self):

        localctx = TDantlrParser.Format_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_format_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.match(TDantlrParser.K_FORMAT)
            self.state = 303
            self.match(TDantlrParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return TDantlrParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ExprRule09Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def STAR(self):
            return self.getToken(TDantlrParser.STAR, 0)
        def DIV(self):
            return self.getToken(TDantlrParser.DIV, 0)
        def MOD(self):
            return self.getToken(TDantlrParser.MOD, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule09" ):
                listener.enterExprRule09(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule09" ):
                listener.exitExprRule09(self)


    class ExprRule07Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def PIPE2(self):
            return self.getToken(TDantlrParser.PIPE2, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule07" ):
                listener.enterExprRule07(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule07" ):
                listener.exitExprRule07(self)


    class ExprRule18Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def K_BETWEEN(self):
            return self.getToken(TDantlrParser.K_BETWEEN, 0)
        def K_AND(self):
            return self.getToken(TDantlrParser.K_AND, 0)
        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule18" ):
                listener.enterExprRule18(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule18" ):
                listener.exitExprRule18(self)


    class ExprRule08Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def PLUS(self):
            return self.getToken(TDantlrParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(TDantlrParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule08" ):
                listener.enterExprRule08(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule08" ):
                listener.exitExprRule08(self)


    class ExprRule19Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)

        def K_IN(self):
            return self.getToken(TDantlrParser.K_IN, 0)
        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)
        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)
        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)

        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)
        def select_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Select_exprContext,0)

        def expr_list(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_listContext,0)

        def database_name(self):
            return self.getTypedRuleContext(TDantlrParser.Database_nameContext,0)

        def DOT(self):
            return self.getToken(TDantlrParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule19" ):
                listener.enterExprRule19(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule19" ):
                listener.exitExprRule19(self)


    class ExprRule01Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal_value(self):
            return self.getTypedRuleContext(TDantlrParser.Literal_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule01" ):
                listener.enterExprRule01(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule01" ):
                listener.exitExprRule01(self)


    class ExprRule12Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def function_name(self):
            return self.getTypedRuleContext(TDantlrParser.Function_nameContext,0)

        def database_name(self):
            return self.getTypedRuleContext(TDantlrParser.Database_nameContext,0)

        def DOT(self):
            return self.getToken(TDantlrParser.DOT, 0)
        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)
        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def STAR(self):
            return self.getToken(TDantlrParser.STAR, 0)
        def K_FROM(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_FROM)
            else:
                return self.getToken(TDantlrParser.K_FROM, i)
        def K_DISTINCT(self):
            return self.getToken(TDantlrParser.K_DISTINCT, 0)
        def K_BOTH(self):
            return self.getToken(TDantlrParser.K_BOTH, 0)
        def K_LEADING(self):
            return self.getToken(TDantlrParser.K_LEADING, 0)
        def K_TRAILING(self):
            return self.getToken(TDantlrParser.K_TRAILING, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)
        def K_FOR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_FOR)
            else:
                return self.getToken(TDantlrParser.K_FOR, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule12" ):
                listener.enterExprRule12(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule12" ):
                listener.exitExprRule12(self)


    class ExprRule23Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)

        def case_specific(self):
            return self.getTypedRuleContext(TDantlrParser.Case_specificContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule23" ):
                listener.enterExprRule23(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule23" ):
                listener.exitExprRule23(self)


    class ExprRule02Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def column_name(self):
            return self.getTypedRuleContext(TDantlrParser.Column_nameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule02" ):
                listener.enterExprRule02(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule02" ):
                listener.exitExprRule02(self)


    class ExprRule13Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def analytical_function_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Analytical_function_exprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule13" ):
                listener.enterExprRule13(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule13" ):
                listener.exitExprRule13(self)


    class ExprRule21Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_CASE(self):
            return self.getToken(TDantlrParser.K_CASE, 0)
        def K_END(self):
            return self.getToken(TDantlrParser.K_END, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def K_WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_WHEN)
            else:
                return self.getToken(TDantlrParser.K_WHEN, i)
        def K_THEN(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_THEN)
            else:
                return self.getToken(TDantlrParser.K_THEN, i)
        def K_ELSE(self):
            return self.getToken(TDantlrParser.K_ELSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule21" ):
                listener.enterExprRule21(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule21" ):
                listener.exitExprRule21(self)


    class ExprRule10Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def LT(self):
            return self.getToken(TDantlrParser.LT, 0)
        def LT_EQ(self):
            return self.getToken(TDantlrParser.LT_EQ, 0)
        def GT(self):
            return self.getToken(TDantlrParser.GT, 0)
        def GT_EQ(self):
            return self.getToken(TDantlrParser.GT_EQ, 0)
        def ASSIGN(self):
            return self.getToken(TDantlrParser.ASSIGN, 0)
        def EQ(self):
            return self.getToken(TDantlrParser.EQ, 0)
        def NOT_EQ1(self):
            return self.getToken(TDantlrParser.NOT_EQ1, 0)
        def NOT_EQ2(self):
            return self.getToken(TDantlrParser.NOT_EQ2, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule10" ):
                listener.enterExprRule10(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule10" ):
                listener.exitExprRule10(self)


    class ExprRule11Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def K_AND(self):
            return self.getToken(TDantlrParser.K_AND, 0)
        def K_OR(self):
            return self.getToken(TDantlrParser.K_OR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule11" ):
                listener.enterExprRule11(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule11" ):
                listener.exitExprRule11(self)


    class ExprRule22Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)

        def field_mode_cast(self):
            return self.getTypedRuleContext(TDantlrParser.Field_mode_castContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule22" ):
                listener.enterExprRule22(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule22" ):
                listener.exitExprRule22(self)


    class ExprRule05Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def extract_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Extract_exprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule05" ):
                listener.enterExprRule05(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule05" ):
                listener.exitExprRule05(self)


    class ExprRule16Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)

        def K_LIKE(self):
            return self.getToken(TDantlrParser.K_LIKE, 0)
        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)
        def K_ESCAPE(self):
            return self.getToken(TDantlrParser.K_ESCAPE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule16" ):
                listener.enterExprRule16(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule16" ):
                listener.exitExprRule16(self)


    class ExprRule06Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def interval_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Interval_exprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule06" ):
                listener.enterExprRule06(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule06" ):
                listener.exitExprRule06(self)


    class ExprRule17Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)

        def K_IS(self):
            return self.getToken(TDantlrParser.K_IS, 0)
        def K_NULL(self):
            return self.getToken(TDantlrParser.K_NULL, 0)
        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule17" ):
                listener.enterExprRule17(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule17" ):
                listener.exitExprRule17(self)


    class ExprRule03Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def column_list(self):
            return self.getTypedRuleContext(TDantlrParser.Column_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule03" ):
                listener.enterExprRule03(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule03" ):
                listener.exitExprRule03(self)


    class ExprRule14Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)
        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)

        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule14" ):
                listener.enterExprRule14(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule14" ):
                listener.exitExprRule14(self)


    class ExprRule04Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unary_operator(self):
            return self.getTypedRuleContext(TDantlrParser.Unary_operatorContext,0)

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule04" ):
                listener.enterExprRule04(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule04" ):
                listener.exitExprRule04(self)


    class ExprRule15Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_CAST(self):
            return self.getToken(TDantlrParser.K_CAST, 0)
        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)
        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)

        def K_AS(self):
            return self.getToken(TDantlrParser.K_AS, 0)
        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)
        def type_name(self):
            return self.getTypedRuleContext(TDantlrParser.Type_nameContext,0)

        def case_specific(self):
            return self.getTypedRuleContext(TDantlrParser.Case_specificContext,0)

        def format_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Format_exprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule15" ):
                listener.enterExprRule15(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule15" ):
                listener.exitExprRule15(self)


    class ExprRule20Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TDantlrParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)
        def subquery(self):
            return self.getTypedRuleContext(TDantlrParser.SubqueryContext,0)

        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)
        def K_EXISTS(self):
            return self.getToken(TDantlrParser.K_EXISTS, 0)
        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprRule20" ):
                listener.enterExprRule20(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprRule20" ):
                listener.exitExprRule20(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TDantlrParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 24
        self.enterRecursionRule(localctx, 24, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 390
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                localctx = TDantlrParser.ExprRule01Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 306
                self.literal_value()
                pass

            elif la_ == 2:
                localctx = TDantlrParser.ExprRule02Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 307
                self.column_name()
                pass

            elif la_ == 3:
                localctx = TDantlrParser.ExprRule03Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 308
                self.column_list()
                pass

            elif la_ == 4:
                localctx = TDantlrParser.ExprRule04Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 309
                self.unary_operator()
                self.state = 310
                self.expr(20)
                pass

            elif la_ == 5:
                localctx = TDantlrParser.ExprRule05Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 312
                self.extract_expr()
                pass

            elif la_ == 6:
                localctx = TDantlrParser.ExprRule06Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 313
                self.interval_expr()
                pass

            elif la_ == 7:
                localctx = TDantlrParser.ExprRule12Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 317
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
                if la_ == 1:
                    self.state = 314
                    self.database_name()
                    self.state = 315
                    self.match(TDantlrParser.DOT)


                self.state = 319
                self.function_name()
                self.state = 339
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
                if la_ == 1:
                    self.state = 320
                    self.match(TDantlrParser.OPEN_PAR)
                    self.state = 336
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [TDantlrParser.OPEN_PAR, TDantlrParser.PLUS, TDantlrParser.MINUS, TDantlrParser.TILDE, TDantlrParser.K_MAX, TDantlrParser.K_CORR, TDantlrParser.K_MAXIMUM, TDantlrParser.K_ABS, TDantlrParser.K_COS, TDantlrParser.K_FROM, TDantlrParser.K_QUANTILE, TDantlrParser.K_STDDEV_POP, TDantlrParser.K_COSH, TDantlrParser.K_MDIFF, TDantlrParser.K_RADIANS, TDantlrParser.K_STDDEV_SAMP, TDantlrParser.K_ACCOUNT, TDantlrParser.K_COUNT, TDantlrParser.K_RANDOM, TDantlrParser.K_ACOS, TDantlrParser.K_COVAR_POP, TDantlrParser.K_MIN, TDantlrParser.K_RANGE_N, TDantlrParser.K_STRING_CS, TDantlrParser.K_ACOSH, TDantlrParser.K_COVAR_SAMP, TDantlrParser.K_RANK, TDantlrParser.K_MINIMUM, TDantlrParser.K_SUBSTR, TDantlrParser.K_ADD_MONTHS, TDantlrParser.K_SUBSTRING, TDantlrParser.K_MINUTE, TDantlrParser.K_SUM, TDantlrParser.K_CSUM, TDantlrParser.K_MLINREG, TDantlrParser.K_REGR_AVGX, TDantlrParser.K_REGR_AVGY, TDantlrParser.K_MOD, TDantlrParser.K_REGR_COUNT, TDantlrParser.K_CURRENT_DATE, TDantlrParser.K_REGR_INTERCEPT, TDantlrParser.K_TAN, TDantlrParser.K_CURRENT_TIME, TDantlrParser.K_REGR_R2, TDantlrParser.K_TANH, TDantlrParser.K_CURRENT_TIMESTAMP, TDantlrParser.K_REGR_SLOPE, TDantlrParser.K_REGR_SXX, TDantlrParser.K_REGR_SXY, TDantlrParser.K_MONTH, TDantlrParser.K_REGR_SYY, TDantlrParser.K_DATABASE, TDantlrParser.K_MSUM, TDantlrParser.K_TIME, TDantlrParser.K_ASIN, TDantlrParser.K_DATE, TDantlrParser.K_TIMESTAMP, TDantlrParser.K_ASINH, TDantlrParser.K_HOUR, TDantlrParser.K_TIMEZONE_HOUR, TDantlrParser.K_DAY, TDantlrParser.K_TIMEZONE_MINUTE, TDantlrParser.K_ATAN, TDantlrParser.K_TITLE, TDantlrParser.K_ATAN2, TDantlrParser.K_ATANH, TDantlrParser.K_DEFAULT, TDantlrParser.K_TRAILING, TDantlrParser.K_DEGREES, TDantlrParser.K_INDEX, TDantlrParser.K_TRANSLATE, TDantlrParser.K_NOT, TDantlrParser.K_TRANSLATE_CHK, TDantlrParser.K_AVG, TDantlrParser.K_NULL, TDantlrParser.K_TRIM, TDantlrParser.K_NULLIF, TDantlrParser.K_TYPE, TDantlrParser.K_NULLIFZERO, TDantlrParser.K_RIGHT, TDantlrParser.K_BOTH, TDantlrParser.K_DISTINCT, TDantlrParser.K_ROLE, TDantlrParser.K_OCTET_LENGTH, TDantlrParser.K_BYTE, TDantlrParser.K_INTERVAL, TDantlrParser.K_BYTES, TDantlrParser.K_ROW_NUMBER, TDantlrParser.K_UPPER, TDantlrParser.K_CASE, TDantlrParser.K_USER, TDantlrParser.K_CASE_N, TDantlrParser.K_SECOND, TDantlrParser.K_CAST, TDantlrParser.K_KURTOSIS, TDantlrParser.K_CHAR, TDantlrParser.K_SESSION, TDantlrParser.K_CHAR2HEXINT, TDantlrParser.K_VARGRAPHIC, TDantlrParser.K_LEADING, TDantlrParser.K_CHARACTERS, TDantlrParser.K_VAR_POP, TDantlrParser.K_CHARACTER_LENGTH, TDantlrParser.K_LEFT, TDantlrParser.K_VAR_SAMP, TDantlrParser.K_CHARS, TDantlrParser.K_CHAR_LENGTH, TDantlrParser.K_SIN, TDantlrParser.K_LN, TDantlrParser.K_PERCENT_RANK, TDantlrParser.K_SINH, TDantlrParser.K_EXISTS, TDantlrParser.K_SKEW, TDantlrParser.K_EXP, TDantlrParser.K_POSITION, TDantlrParser.K_SOUNDEX, TDantlrParser.K_WIDTH_BUCKET, TDantlrParser.K_COALESCE, TDantlrParser.K_EXTRACT, TDantlrParser.K_LOG, TDantlrParser.K_YEAR, TDantlrParser.K_ZEROIFNULL, TDantlrParser.K_LOWER, TDantlrParser.K_PROFILE, TDantlrParser.K_SQRT, TDantlrParser.K_FORMAT, TDantlrParser.K_MAVG, TDantlrParser.K_LTRIM, TDantlrParser.K_RTRIM, TDantlrParser.K_LPAD, TDantlrParser.K_RPAD, TDantlrParser.K_CUME_DIST, TDantlrParser.K_DENSE_RANK, TDantlrParser.K_FIRST_VALUE, TDantlrParser.K_LAST_VALUE, TDantlrParser.K_MEDIAN, TDantlrParser.K_PERCENTILE_CON, TDantlrParser.K_PERCENTILE_DIS, TDantlrParser.K_CEILING, TDantlrParser.K_FLOOR, TDantlrParser.K_POWER, TDantlrParser.K_ROUND, TDantlrParser.K_SIGN, TDantlrParser.K_TRUNC, TDantlrParser.K_DEGREESRADIANS, TDantlrParser.K_NVL, TDantlrParser.K_NVL2, TDantlrParser.K_ASCII, TDantlrParser.K_CHR, TDantlrParser.K_CSVLD, TDantlrParser.K_EDITDISTANCE, TDantlrParser.K_INITCAP, TDantlrParser.K_INSTR, TDantlrParser.K_NGRAM, TDantlrParser.K_NVP, TDantlrParser.K_OREPLACE, TDantlrParser.K_OTRANSLATE, TDantlrParser.K_STRTOK, TDantlrParser.K_STRTOK_SPLIT_TO_TABLE, TDantlrParser.K_LENGTH, TDantlrParser.K_CSV, TDantlrParser.K_CURRENT_ROLE, TDantlrParser.K_CURRENT_USER, TDantlrParser.K_TEMPORAL_DATE, TDantlrParser.K_TEMPORAL_TIMESTAMP, TDantlrParser.K_BITAND, TDantlrParser.K_BITNOT, TDantlrParser.K_BITOR, TDantlrParser.K_BITXOR, TDantlrParser.K_COUNTSET, TDantlrParser.K_GETBIT, TDantlrParser.K_ROTATELEFT, TDantlrParser.K_ROTATERIGHT, TDantlrParser.K_SETBIT, TDantlrParser.K_SHIFTLEFT, TDantlrParser.K_SHIFTRIGHT, TDantlrParser.K_SUBBITSTR, TDantlrParser.K_TO_BYTE, TDantlrParser.K_TO_CHAR, TDantlrParser.K_TO_DATE, TDantlrParser.K_TO_TIMESTAMP, TDantlrParser.K_TO_NUMBER, TDantlrParser.K_OADD_MONTHS, TDantlrParser.K_GROUPING, TDantlrParser.K_CEIL, TDantlrParser.K_GREATEST, TDantlrParser.K_LEAST, TDantlrParser.K_LAST_DAY, TDantlrParser.K_NEXT_DAY, TDantlrParser.K_MONTHS_BETWEEN, TDantlrParser.K_REVERSE, TDantlrParser.K_TD_DAY_OF_WEEK, TDantlrParser.K_TD_DAY_OF_MONTH, TDantlrParser.K_TD_DAY_OF_YEAR, TDantlrParser.K_TD_WEEK_OF_YEAR, TDantlrParser.K_TD_MONTH_OF_QUARTER, TDantlrParser.K_TD_MONTH_OF_YEAR, TDantlrParser.K_TD_QUARTER_OF_YEAR, TDantlrParser.NUMERIC_LITERAL, TDantlrParser.IDENTIFIER, TDantlrParser.STRING_LITERAL]:
                        self.state = 322
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (TDantlrParser.K_TRAILING - 192)) | (1 << (TDantlrParser.K_BOTH - 192)) | (1 << (TDantlrParser.K_DISTINCT - 192)))) != 0) or _la==TDantlrParser.K_LEADING:
                            self.state = 321
                            _la = self._input.LA(1)
                            if not(((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (TDantlrParser.K_TRAILING - 192)) | (1 << (TDantlrParser.K_BOTH - 192)) | (1 << (TDantlrParser.K_DISTINCT - 192)))) != 0) or _la==TDantlrParser.K_LEADING):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 325
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==TDantlrParser.K_FROM:
                            self.state = 324
                            self.match(TDantlrParser.K_FROM)


                        self.state = 327
                        self.expr(0)
                        self.state = 332
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==TDantlrParser.COMMA or _la==TDantlrParser.K_FROM or _la==TDantlrParser.K_FOR:
                            self.state = 328
                            _la = self._input.LA(1)
                            if not(_la==TDantlrParser.COMMA or _la==TDantlrParser.K_FROM or _la==TDantlrParser.K_FOR):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            self.state = 329
                            self.expr(0)
                            self.state = 334
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        pass
                    elif token in [TDantlrParser.STAR]:
                        self.state = 335
                        self.match(TDantlrParser.STAR)
                        pass
                    elif token in [TDantlrParser.CLOSE_PAR]:
                        pass
                    else:
                        pass
                    self.state = 338
                    self.match(TDantlrParser.CLOSE_PAR)


                pass

            elif la_ == 8:
                localctx = TDantlrParser.ExprRule13Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 341
                self.analytical_function_expr()
                pass

            elif la_ == 9:
                localctx = TDantlrParser.ExprRule14Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 342
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 343
                self.expr(0)
                self.state = 344
                self.match(TDantlrParser.CLOSE_PAR)
                pass

            elif la_ == 10:
                localctx = TDantlrParser.ExprRule15Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 346
                self.match(TDantlrParser.K_CAST)
                self.state = 347
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 348
                self.expr(0)
                self.state = 349
                self.match(TDantlrParser.K_AS)
                self.state = 351
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 122)) & ~0x3f) == 0 and ((1 << (_la - 122)) & ((1 << (TDantlrParser.K_CURSOR - 122)) | (1 << (TDantlrParser.K_TIME - 122)) | (1 << (TDantlrParser.K_DATE - 122)) | (1 << (TDantlrParser.K_TIMESTAMP - 122)) | (1 << (TDantlrParser.K_DEC - 122)) | (1 << (TDantlrParser.K_DECIMAL - 122)))) != 0) or ((((_la - 235)) & ~0x3f) == 0 and ((1 << (_la - 235)) & ((1 << (TDantlrParser.K_BLOB - 235)) | (1 << (TDantlrParser.K_NUMERIC - 235)) | (1 << (TDantlrParser.K_INT - 235)) | (1 << (TDantlrParser.K_DOUBLE - 235)) | (1 << (TDantlrParser.K_INTEGER - 235)) | (1 << (TDantlrParser.K_BYTE - 235)) | (1 << (TDantlrParser.K_BYTEINT - 235)))) != 0) or ((((_la - 318)) & ~0x3f) == 0 and ((1 << (_la - 318)) & ((1 << (TDantlrParser.K_VARBYTE - 318)) | (1 << (TDantlrParser.K_CHAR - 318)) | (1 << (TDantlrParser.K_VARCHAR - 318)) | (1 << (TDantlrParser.K_CHARACTER - 318)) | (1 << (TDantlrParser.K_SMALLINT - 318)))) != 0) or _la==TDantlrParser.K_FLOAT or _la==TDantlrParser.K_BIGINT:
                    self.state = 350
                    self.type_name()


                self.state = 354
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.OPEN_PAR or _la==TDantlrParser.K_CS or _la==TDantlrParser.K_NOT or _la==TDantlrParser.K_UC or _la==TDantlrParser.K_UPPERCASE or _la==TDantlrParser.K_CASESPECIFIC:
                    self.state = 353
                    self.case_specific()


                self.state = 357
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_FORMAT:
                    self.state = 356
                    self.format_expr()


                self.state = 359
                self.match(TDantlrParser.CLOSE_PAR)
                pass

            elif la_ == 11:
                localctx = TDantlrParser.ExprRule20Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 365
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_NOT or _la==TDantlrParser.K_EXISTS:
                    self.state = 362
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==TDantlrParser.K_NOT:
                        self.state = 361
                        self.match(TDantlrParser.K_NOT)


                    self.state = 364
                    self.match(TDantlrParser.K_EXISTS)


                self.state = 367
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 368
                self.subquery()
                self.state = 369
                self.match(TDantlrParser.CLOSE_PAR)
                pass

            elif la_ == 12:
                localctx = TDantlrParser.ExprRule21Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 371
                self.match(TDantlrParser.K_CASE)
                self.state = 373
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (TDantlrParser.OPEN_PAR - 3)) | (1 << (TDantlrParser.PLUS - 3)) | (1 << (TDantlrParser.MINUS - 3)) | (1 << (TDantlrParser.TILDE - 3)) | (1 << (TDantlrParser.K_MAX - 3)) | (1 << (TDantlrParser.K_CORR - 3)) | (1 << (TDantlrParser.K_MAXIMUM - 3)) | (1 << (TDantlrParser.K_ABS - 3)) | (1 << (TDantlrParser.K_COS - 3)) | (1 << (TDantlrParser.K_QUANTILE - 3)) | (1 << (TDantlrParser.K_STDDEV_POP - 3)) | (1 << (TDantlrParser.K_COSH - 3)) | (1 << (TDantlrParser.K_MDIFF - 3)) | (1 << (TDantlrParser.K_RADIANS - 3)) | (1 << (TDantlrParser.K_STDDEV_SAMP - 3)) | (1 << (TDantlrParser.K_ACCOUNT - 3)) | (1 << (TDantlrParser.K_COUNT - 3)) | (1 << (TDantlrParser.K_RANDOM - 3)) | (1 << (TDantlrParser.K_ACOS - 3)) | (1 << (TDantlrParser.K_COVAR_POP - 3)) | (1 << (TDantlrParser.K_MIN - 3)) | (1 << (TDantlrParser.K_RANGE_N - 3)) | (1 << (TDantlrParser.K_STRING_CS - 3)) | (1 << (TDantlrParser.K_ACOSH - 3)) | (1 << (TDantlrParser.K_COVAR_SAMP - 3)) | (1 << (TDantlrParser.K_RANK - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (TDantlrParser.K_MINIMUM - 70)) | (1 << (TDantlrParser.K_SUBSTR - 70)) | (1 << (TDantlrParser.K_ADD_MONTHS - 70)) | (1 << (TDantlrParser.K_SUBSTRING - 70)) | (1 << (TDantlrParser.K_MINUTE - 70)) | (1 << (TDantlrParser.K_SUM - 70)) | (1 << (TDantlrParser.K_CSUM - 70)) | (1 << (TDantlrParser.K_MLINREG - 70)) | (1 << (TDantlrParser.K_REGR_AVGX - 70)) | (1 << (TDantlrParser.K_REGR_AVGY - 70)) | (1 << (TDantlrParser.K_MOD - 70)) | (1 << (TDantlrParser.K_REGR_COUNT - 70)) | (1 << (TDantlrParser.K_CURRENT_DATE - 70)) | (1 << (TDantlrParser.K_REGR_INTERCEPT - 70)) | (1 << (TDantlrParser.K_TAN - 70)) | (1 << (TDantlrParser.K_CURRENT_TIME - 70)) | (1 << (TDantlrParser.K_REGR_R2 - 70)) | (1 << (TDantlrParser.K_TANH - 70)) | (1 << (TDantlrParser.K_CURRENT_TIMESTAMP - 70)) | (1 << (TDantlrParser.K_REGR_SLOPE - 70)) | (1 << (TDantlrParser.K_REGR_SXX - 70)) | (1 << (TDantlrParser.K_REGR_SXY - 70)))) != 0) or ((((_la - 136)) & ~0x3f) == 0 and ((1 << (_la - 136)) & ((1 << (TDantlrParser.K_MONTH - 136)) | (1 << (TDantlrParser.K_REGR_SYY - 136)) | (1 << (TDantlrParser.K_DATABASE - 136)) | (1 << (TDantlrParser.K_MSUM - 136)) | (1 << (TDantlrParser.K_TIME - 136)) | (1 << (TDantlrParser.K_ASIN - 136)) | (1 << (TDantlrParser.K_DATE - 136)) | (1 << (TDantlrParser.K_TIMESTAMP - 136)) | (1 << (TDantlrParser.K_ASINH - 136)) | (1 << (TDantlrParser.K_HOUR - 136)) | (1 << (TDantlrParser.K_TIMEZONE_HOUR - 136)) | (1 << (TDantlrParser.K_DAY - 136)) | (1 << (TDantlrParser.K_TIMEZONE_MINUTE - 136)) | (1 << (TDantlrParser.K_ATAN - 136)) | (1 << (TDantlrParser.K_TITLE - 136)) | (1 << (TDantlrParser.K_ATAN2 - 136)) | (1 << (TDantlrParser.K_ATANH - 136)) | (1 << (TDantlrParser.K_DEFAULT - 136)) | (1 << (TDantlrParser.K_DEGREES - 136)) | (1 << (TDantlrParser.K_INDEX - 136)))) != 0) or ((((_la - 204)) & ~0x3f) == 0 and ((1 << (_la - 204)) & ((1 << (TDantlrParser.K_TRANSLATE - 204)) | (1 << (TDantlrParser.K_NOT - 204)) | (1 << (TDantlrParser.K_TRANSLATE_CHK - 204)) | (1 << (TDantlrParser.K_AVG - 204)) | (1 << (TDantlrParser.K_NULL - 204)) | (1 << (TDantlrParser.K_TRIM - 204)) | (1 << (TDantlrParser.K_NULLIF - 204)) | (1 << (TDantlrParser.K_TYPE - 204)) | (1 << (TDantlrParser.K_NULLIFZERO - 204)) | (1 << (TDantlrParser.K_RIGHT - 204)) | (1 << (TDantlrParser.K_ROLE - 204)) | (1 << (TDantlrParser.K_OCTET_LENGTH - 204)) | (1 << (TDantlrParser.K_BYTE - 204)))) != 0) or ((((_la - 273)) & ~0x3f) == 0 and ((1 << (_la - 273)) & ((1 << (TDantlrParser.K_INTERVAL - 273)) | (1 << (TDantlrParser.K_BYTES - 273)) | (1 << (TDantlrParser.K_ROW_NUMBER - 273)) | (1 << (TDantlrParser.K_UPPER - 273)) | (1 << (TDantlrParser.K_CASE - 273)) | (1 << (TDantlrParser.K_USER - 273)) | (1 << (TDantlrParser.K_CASE_N - 273)) | (1 << (TDantlrParser.K_SECOND - 273)) | (1 << (TDantlrParser.K_CAST - 273)) | (1 << (TDantlrParser.K_KURTOSIS - 273)) | (1 << (TDantlrParser.K_CHAR - 273)) | (1 << (TDantlrParser.K_SESSION - 273)) | (1 << (TDantlrParser.K_CHAR2HEXINT - 273)) | (1 << (TDantlrParser.K_VARGRAPHIC - 273)))) != 0) or ((((_la - 337)) & ~0x3f) == 0 and ((1 << (_la - 337)) & ((1 << (TDantlrParser.K_CHARACTERS - 337)) | (1 << (TDantlrParser.K_VAR_POP - 337)) | (1 << (TDantlrParser.K_CHARACTER_LENGTH - 337)) | (1 << (TDantlrParser.K_LEFT - 337)) | (1 << (TDantlrParser.K_VAR_SAMP - 337)) | (1 << (TDantlrParser.K_CHARS - 337)) | (1 << (TDantlrParser.K_CHAR_LENGTH - 337)) | (1 << (TDantlrParser.K_SIN - 337)) | (1 << (TDantlrParser.K_LN - 337)) | (1 << (TDantlrParser.K_PERCENT_RANK - 337)) | (1 << (TDantlrParser.K_SINH - 337)) | (1 << (TDantlrParser.K_EXISTS - 337)) | (1 << (TDantlrParser.K_SKEW - 337)) | (1 << (TDantlrParser.K_EXP - 337)) | (1 << (TDantlrParser.K_POSITION - 337)) | (1 << (TDantlrParser.K_SOUNDEX - 337)) | (1 << (TDantlrParser.K_WIDTH_BUCKET - 337)) | (1 << (TDantlrParser.K_COALESCE - 337)) | (1 << (TDantlrParser.K_EXTRACT - 337)) | (1 << (TDantlrParser.K_LOG - 337)))) != 0) or ((((_la - 414)) & ~0x3f) == 0 and ((1 << (_la - 414)) & ((1 << (TDantlrParser.K_YEAR - 414)) | (1 << (TDantlrParser.K_ZEROIFNULL - 414)) | (1 << (TDantlrParser.K_LOWER - 414)) | (1 << (TDantlrParser.K_PROFILE - 414)) | (1 << (TDantlrParser.K_SQRT - 414)) | (1 << (TDantlrParser.K_FORMAT - 414)) | (1 << (TDantlrParser.K_MAVG - 414)) | (1 << (TDantlrParser.K_LTRIM - 414)) | (1 << (TDantlrParser.K_RTRIM - 414)) | (1 << (TDantlrParser.K_LPAD - 414)) | (1 << (TDantlrParser.K_RPAD - 414)) | (1 << (TDantlrParser.K_CUME_DIST - 414)) | (1 << (TDantlrParser.K_DENSE_RANK - 414)) | (1 << (TDantlrParser.K_FIRST_VALUE - 414)) | (1 << (TDantlrParser.K_LAST_VALUE - 414)) | (1 << (TDantlrParser.K_MEDIAN - 414)) | (1 << (TDantlrParser.K_PERCENTILE_CON - 414)) | (1 << (TDantlrParser.K_PERCENTILE_DIS - 414)) | (1 << (TDantlrParser.K_CEILING - 414)) | (1 << (TDantlrParser.K_FLOOR - 414)) | (1 << (TDantlrParser.K_POWER - 414)) | (1 << (TDantlrParser.K_ROUND - 414)) | (1 << (TDantlrParser.K_SIGN - 414)))) != 0) or ((((_la - 478)) & ~0x3f) == 0 and ((1 << (_la - 478)) & ((1 << (TDantlrParser.K_TRUNC - 478)) | (1 << (TDantlrParser.K_DEGREESRADIANS - 478)) | (1 << (TDantlrParser.K_NVL - 478)) | (1 << (TDantlrParser.K_NVL2 - 478)) | (1 << (TDantlrParser.K_ASCII - 478)) | (1 << (TDantlrParser.K_CHR - 478)) | (1 << (TDantlrParser.K_CSVLD - 478)) | (1 << (TDantlrParser.K_EDITDISTANCE - 478)) | (1 << (TDantlrParser.K_INITCAP - 478)) | (1 << (TDantlrParser.K_INSTR - 478)) | (1 << (TDantlrParser.K_NGRAM - 478)) | (1 << (TDantlrParser.K_NVP - 478)) | (1 << (TDantlrParser.K_OREPLACE - 478)) | (1 << (TDantlrParser.K_OTRANSLATE - 478)) | (1 << (TDantlrParser.K_STRTOK - 478)) | (1 << (TDantlrParser.K_STRTOK_SPLIT_TO_TABLE - 478)) | (1 << (TDantlrParser.K_LENGTH - 478)) | (1 << (TDantlrParser.K_CSV - 478)) | (1 << (TDantlrParser.K_CURRENT_ROLE - 478)) | (1 << (TDantlrParser.K_CURRENT_USER - 478)) | (1 << (TDantlrParser.K_TEMPORAL_DATE - 478)) | (1 << (TDantlrParser.K_TEMPORAL_TIMESTAMP - 478)) | (1 << (TDantlrParser.K_BITAND - 478)) | (1 << (TDantlrParser.K_BITNOT - 478)) | (1 << (TDantlrParser.K_BITOR - 478)) | (1 << (TDantlrParser.K_BITXOR - 478)) | (1 << (TDantlrParser.K_COUNTSET - 478)) | (1 << (TDantlrParser.K_GETBIT - 478)) | (1 << (TDantlrParser.K_ROTATELEFT - 478)) | (1 << (TDantlrParser.K_ROTATERIGHT - 478)) | (1 << (TDantlrParser.K_SETBIT - 478)) | (1 << (TDantlrParser.K_SHIFTLEFT - 478)) | (1 << (TDantlrParser.K_SHIFTRIGHT - 478)) | (1 << (TDantlrParser.K_SUBBITSTR - 478)) | (1 << (TDantlrParser.K_TO_BYTE - 478)) | (1 << (TDantlrParser.K_TO_CHAR - 478)) | (1 << (TDantlrParser.K_TO_DATE - 478)) | (1 << (TDantlrParser.K_TO_TIMESTAMP - 478)) | (1 << (TDantlrParser.K_TO_NUMBER - 478)) | (1 << (TDantlrParser.K_OADD_MONTHS - 478)) | (1 << (TDantlrParser.K_GROUPING - 478)) | (1 << (TDantlrParser.K_CEIL - 478)) | (1 << (TDantlrParser.K_GREATEST - 478)) | (1 << (TDantlrParser.K_LEAST - 478)) | (1 << (TDantlrParser.K_LAST_DAY - 478)) | (1 << (TDantlrParser.K_NEXT_DAY - 478)) | (1 << (TDantlrParser.K_MONTHS_BETWEEN - 478)) | (1 << (TDantlrParser.K_REVERSE - 478)) | (1 << (TDantlrParser.K_TD_DAY_OF_WEEK - 478)) | (1 << (TDantlrParser.K_TD_DAY_OF_MONTH - 478)) | (1 << (TDantlrParser.K_TD_DAY_OF_YEAR - 478)) | (1 << (TDantlrParser.K_TD_WEEK_OF_YEAR - 478)) | (1 << (TDantlrParser.K_TD_MONTH_OF_QUARTER - 478)) | (1 << (TDantlrParser.K_TD_MONTH_OF_YEAR - 478)) | (1 << (TDantlrParser.K_TD_QUARTER_OF_YEAR - 478)) | (1 << (TDantlrParser.NUMERIC_LITERAL - 478)) | (1 << (TDantlrParser.IDENTIFIER - 478)) | (1 << (TDantlrParser.STRING_LITERAL - 478)))) != 0):
                    self.state = 372
                    self.expr(0)


                self.state = 380 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 375
                    self.match(TDantlrParser.K_WHEN)
                    self.state = 376
                    self.expr(0)
                    self.state = 377
                    self.match(TDantlrParser.K_THEN)
                    self.state = 378
                    self.expr(0)
                    self.state = 382 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==TDantlrParser.K_WHEN):
                        break

                self.state = 386
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_ELSE:
                    self.state = 384
                    self.match(TDantlrParser.K_ELSE)
                    self.state = 385
                    self.expr(0)


                self.state = 388
                self.match(TDantlrParser.K_END)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 461
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,54,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 459
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
                    if la_ == 1:
                        localctx = TDantlrParser.ExprRule07Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 392
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 393
                        self.match(TDantlrParser.PIPE2)
                        self.state = 394
                        self.expr(18)
                        pass

                    elif la_ == 2:
                        localctx = TDantlrParser.ExprRule08Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 395
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 396
                        _la = self._input.LA(1)
                        if not(_la==TDantlrParser.PLUS or _la==TDantlrParser.MINUS):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 397
                        self.expr(17)
                        pass

                    elif la_ == 3:
                        localctx = TDantlrParser.ExprRule09Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 398
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 399
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TDantlrParser.STAR) | (1 << TDantlrParser.DIV) | (1 << TDantlrParser.MOD))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 400
                        self.expr(16)
                        pass

                    elif la_ == 4:
                        localctx = TDantlrParser.ExprRule10Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 401
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 402
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TDantlrParser.ASSIGN) | (1 << TDantlrParser.LT) | (1 << TDantlrParser.LT_EQ) | (1 << TDantlrParser.GT) | (1 << TDantlrParser.GT_EQ) | (1 << TDantlrParser.EQ) | (1 << TDantlrParser.NOT_EQ1) | (1 << TDantlrParser.NOT_EQ2))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 403
                        self.expr(15)
                        pass

                    elif la_ == 5:
                        localctx = TDantlrParser.ExprRule11Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 404
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 405
                        _la = self._input.LA(1)
                        if not(_la==TDantlrParser.K_AND or _la==TDantlrParser.K_OR):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 406
                        self.expr(14)
                        pass

                    elif la_ == 6:
                        localctx = TDantlrParser.ExprRule18Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 407
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 409
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==TDantlrParser.K_NOT:
                            self.state = 408
                            self.match(TDantlrParser.K_NOT)


                        self.state = 411
                        self.match(TDantlrParser.K_BETWEEN)
                        self.state = 412
                        self.expr(0)
                        self.state = 413
                        self.match(TDantlrParser.K_AND)
                        self.state = 414
                        self.expr(7)
                        pass

                    elif la_ == 7:
                        localctx = TDantlrParser.ExprRule16Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 416
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 418
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==TDantlrParser.K_NOT:
                            self.state = 417
                            self.match(TDantlrParser.K_NOT)


                        self.state = 420
                        self.match(TDantlrParser.K_LIKE)
                        self.state = 421
                        self.expr(0)
                        self.state = 424
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                        if la_ == 1:
                            self.state = 422
                            self.match(TDantlrParser.K_ESCAPE)
                            self.state = 423
                            self.expr(0)


                        pass

                    elif la_ == 8:
                        localctx = TDantlrParser.ExprRule17Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 426
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 434
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
                        if la_ == 1:
                            self.state = 427
                            self.match(TDantlrParser.K_IS)
                            self.state = 428
                            self.match(TDantlrParser.K_NULL)
                            pass

                        elif la_ == 2:
                            self.state = 429
                            self.match(TDantlrParser.K_IS)
                            self.state = 430
                            self.match(TDantlrParser.K_NOT)
                            self.state = 431
                            self.match(TDantlrParser.K_NULL)
                            pass

                        elif la_ == 3:
                            self.state = 432
                            self.match(TDantlrParser.K_NOT)
                            self.state = 433
                            self.match(TDantlrParser.K_NULL)
                            pass


                        pass

                    elif la_ == 9:
                        localctx = TDantlrParser.ExprRule19Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 436
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 438
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==TDantlrParser.K_NOT:
                            self.state = 437
                            self.match(TDantlrParser.K_NOT)


                        self.state = 440
                        self.match(TDantlrParser.K_IN)
                        self.state = 453
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [TDantlrParser.OPEN_PAR]:
                            self.state = 441
                            self.match(TDantlrParser.OPEN_PAR)
                            self.state = 444
                            self._errHandler.sync(self)
                            token = self._input.LA(1)
                            if token in [TDantlrParser.K_SEL, TDantlrParser.K_SELECT]:
                                self.state = 442
                                self.select_expr(0)
                                pass
                            elif token in [TDantlrParser.OPEN_PAR, TDantlrParser.PLUS, TDantlrParser.MINUS, TDantlrParser.TILDE, TDantlrParser.K_MAX, TDantlrParser.K_CORR, TDantlrParser.K_MAXIMUM, TDantlrParser.K_ABS, TDantlrParser.K_COS, TDantlrParser.K_QUANTILE, TDantlrParser.K_STDDEV_POP, TDantlrParser.K_COSH, TDantlrParser.K_MDIFF, TDantlrParser.K_RADIANS, TDantlrParser.K_STDDEV_SAMP, TDantlrParser.K_ACCOUNT, TDantlrParser.K_COUNT, TDantlrParser.K_RANDOM, TDantlrParser.K_ACOS, TDantlrParser.K_COVAR_POP, TDantlrParser.K_MIN, TDantlrParser.K_RANGE_N, TDantlrParser.K_STRING_CS, TDantlrParser.K_ACOSH, TDantlrParser.K_COVAR_SAMP, TDantlrParser.K_RANK, TDantlrParser.K_MINIMUM, TDantlrParser.K_SUBSTR, TDantlrParser.K_ADD_MONTHS, TDantlrParser.K_SUBSTRING, TDantlrParser.K_MINUTE, TDantlrParser.K_SUM, TDantlrParser.K_CSUM, TDantlrParser.K_MLINREG, TDantlrParser.K_REGR_AVGX, TDantlrParser.K_REGR_AVGY, TDantlrParser.K_MOD, TDantlrParser.K_REGR_COUNT, TDantlrParser.K_CURRENT_DATE, TDantlrParser.K_REGR_INTERCEPT, TDantlrParser.K_TAN, TDantlrParser.K_CURRENT_TIME, TDantlrParser.K_REGR_R2, TDantlrParser.K_TANH, TDantlrParser.K_CURRENT_TIMESTAMP, TDantlrParser.K_REGR_SLOPE, TDantlrParser.K_REGR_SXX, TDantlrParser.K_REGR_SXY, TDantlrParser.K_MONTH, TDantlrParser.K_REGR_SYY, TDantlrParser.K_DATABASE, TDantlrParser.K_MSUM, TDantlrParser.K_TIME, TDantlrParser.K_ASIN, TDantlrParser.K_DATE, TDantlrParser.K_TIMESTAMP, TDantlrParser.K_ASINH, TDantlrParser.K_HOUR, TDantlrParser.K_TIMEZONE_HOUR, TDantlrParser.K_DAY, TDantlrParser.K_TIMEZONE_MINUTE, TDantlrParser.K_ATAN, TDantlrParser.K_TITLE, TDantlrParser.K_ATAN2, TDantlrParser.K_ATANH, TDantlrParser.K_DEFAULT, TDantlrParser.K_DEGREES, TDantlrParser.K_INDEX, TDantlrParser.K_TRANSLATE, TDantlrParser.K_NOT, TDantlrParser.K_TRANSLATE_CHK, TDantlrParser.K_AVG, TDantlrParser.K_NULL, TDantlrParser.K_TRIM, TDantlrParser.K_NULLIF, TDantlrParser.K_TYPE, TDantlrParser.K_NULLIFZERO, TDantlrParser.K_RIGHT, TDantlrParser.K_ROLE, TDantlrParser.K_OCTET_LENGTH, TDantlrParser.K_BYTE, TDantlrParser.K_INTERVAL, TDantlrParser.K_BYTES, TDantlrParser.K_ROW_NUMBER, TDantlrParser.K_UPPER, TDantlrParser.K_CASE, TDantlrParser.K_USER, TDantlrParser.K_CASE_N, TDantlrParser.K_SECOND, TDantlrParser.K_CAST, TDantlrParser.K_KURTOSIS, TDantlrParser.K_CHAR, TDantlrParser.K_SESSION, TDantlrParser.K_CHAR2HEXINT, TDantlrParser.K_VARGRAPHIC, TDantlrParser.K_CHARACTERS, TDantlrParser.K_VAR_POP, TDantlrParser.K_CHARACTER_LENGTH, TDantlrParser.K_LEFT, TDantlrParser.K_VAR_SAMP, TDantlrParser.K_CHARS, TDantlrParser.K_CHAR_LENGTH, TDantlrParser.K_SIN, TDantlrParser.K_LN, TDantlrParser.K_PERCENT_RANK, TDantlrParser.K_SINH, TDantlrParser.K_EXISTS, TDantlrParser.K_SKEW, TDantlrParser.K_EXP, TDantlrParser.K_POSITION, TDantlrParser.K_SOUNDEX, TDantlrParser.K_WIDTH_BUCKET, TDantlrParser.K_COALESCE, TDantlrParser.K_EXTRACT, TDantlrParser.K_LOG, TDantlrParser.K_YEAR, TDantlrParser.K_ZEROIFNULL, TDantlrParser.K_LOWER, TDantlrParser.K_PROFILE, TDantlrParser.K_SQRT, TDantlrParser.K_FORMAT, TDantlrParser.K_MAVG, TDantlrParser.K_LTRIM, TDantlrParser.K_RTRIM, TDantlrParser.K_LPAD, TDantlrParser.K_RPAD, TDantlrParser.K_CUME_DIST, TDantlrParser.K_DENSE_RANK, TDantlrParser.K_FIRST_VALUE, TDantlrParser.K_LAST_VALUE, TDantlrParser.K_MEDIAN, TDantlrParser.K_PERCENTILE_CON, TDantlrParser.K_PERCENTILE_DIS, TDantlrParser.K_CEILING, TDantlrParser.K_FLOOR, TDantlrParser.K_POWER, TDantlrParser.K_ROUND, TDantlrParser.K_SIGN, TDantlrParser.K_TRUNC, TDantlrParser.K_DEGREESRADIANS, TDantlrParser.K_NVL, TDantlrParser.K_NVL2, TDantlrParser.K_ASCII, TDantlrParser.K_CHR, TDantlrParser.K_CSVLD, TDantlrParser.K_EDITDISTANCE, TDantlrParser.K_INITCAP, TDantlrParser.K_INSTR, TDantlrParser.K_NGRAM, TDantlrParser.K_NVP, TDantlrParser.K_OREPLACE, TDantlrParser.K_OTRANSLATE, TDantlrParser.K_STRTOK, TDantlrParser.K_STRTOK_SPLIT_TO_TABLE, TDantlrParser.K_LENGTH, TDantlrParser.K_CSV, TDantlrParser.K_CURRENT_ROLE, TDantlrParser.K_CURRENT_USER, TDantlrParser.K_TEMPORAL_DATE, TDantlrParser.K_TEMPORAL_TIMESTAMP, TDantlrParser.K_BITAND, TDantlrParser.K_BITNOT, TDantlrParser.K_BITOR, TDantlrParser.K_BITXOR, TDantlrParser.K_COUNTSET, TDantlrParser.K_GETBIT, TDantlrParser.K_ROTATELEFT, TDantlrParser.K_ROTATERIGHT, TDantlrParser.K_SETBIT, TDantlrParser.K_SHIFTLEFT, TDantlrParser.K_SHIFTRIGHT, TDantlrParser.K_SUBBITSTR, TDantlrParser.K_TO_BYTE, TDantlrParser.K_TO_CHAR, TDantlrParser.K_TO_DATE, TDantlrParser.K_TO_TIMESTAMP, TDantlrParser.K_TO_NUMBER, TDantlrParser.K_OADD_MONTHS, TDantlrParser.K_GROUPING, TDantlrParser.K_CEIL, TDantlrParser.K_GREATEST, TDantlrParser.K_LEAST, TDantlrParser.K_LAST_DAY, TDantlrParser.K_NEXT_DAY, TDantlrParser.K_MONTHS_BETWEEN, TDantlrParser.K_REVERSE, TDantlrParser.K_TD_DAY_OF_WEEK, TDantlrParser.K_TD_DAY_OF_MONTH, TDantlrParser.K_TD_DAY_OF_YEAR, TDantlrParser.K_TD_WEEK_OF_YEAR, TDantlrParser.K_TD_MONTH_OF_QUARTER, TDantlrParser.K_TD_MONTH_OF_YEAR, TDantlrParser.K_TD_QUARTER_OF_YEAR, TDantlrParser.NUMERIC_LITERAL, TDantlrParser.IDENTIFIER, TDantlrParser.STRING_LITERAL]:
                                self.state = 443
                                self.expr_list()
                                pass
                            elif token in [TDantlrParser.CLOSE_PAR]:
                                pass
                            else:
                                pass
                            self.state = 446
                            self.match(TDantlrParser.CLOSE_PAR)
                            pass
                        elif token in [TDantlrParser.IDENTIFIER]:
                            self.state = 450
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
                            if la_ == 1:
                                self.state = 447
                                self.database_name()
                                self.state = 448
                                self.match(TDantlrParser.DOT)


                            self.state = 452
                            self.table_name()
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

                    elif la_ == 10:
                        localctx = TDantlrParser.ExprRule22Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 455
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 456
                        self.field_mode_cast()
                        pass

                    elif la_ == 11:
                        localctx = TDantlrParser.ExprRule23Context(self, TDantlrParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 457
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 458
                        self.case_specific()
                        pass

             
                self.state = 463
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,54,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Expr_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_expr_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_list" ):
                listener.enterExpr_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_list" ):
                listener.exitExpr_list(self)




    def expr_list(self):

        localctx = TDantlrParser.Expr_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_expr_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 464
            self.expr(0)
            self.state = 469
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,55,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 465
                    self.match(TDantlrParser.COMMA)
                    self.state = 466
                    self.expr(0) 
                self.state = 471
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,55,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Extract_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FROM(self):
            return self.getToken(TDantlrParser.K_FROM, 0)

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)


        def K_YEAR(self):
            return self.getToken(TDantlrParser.K_YEAR, 0)

        def K_MONTH(self):
            return self.getToken(TDantlrParser.K_MONTH, 0)

        def K_DAY(self):
            return self.getToken(TDantlrParser.K_DAY, 0)

        def K_HOUR(self):
            return self.getToken(TDantlrParser.K_HOUR, 0)

        def K_MINUTE(self):
            return self.getToken(TDantlrParser.K_MINUTE, 0)

        def K_SECOND(self):
            return self.getToken(TDantlrParser.K_SECOND, 0)

        def K_TIMEZONE_HOUR(self):
            return self.getToken(TDantlrParser.K_TIMEZONE_HOUR, 0)

        def K_TIMEZONE_MINUTE(self):
            return self.getToken(TDantlrParser.K_TIMEZONE_MINUTE, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_extract_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtract_expr" ):
                listener.enterExtract_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtract_expr" ):
                listener.exitExtract_expr(self)




    def extract_expr(self):

        localctx = TDantlrParser.Extract_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_extract_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            _la = self._input.LA(1)
            if not(_la==TDantlrParser.K_MINUTE or _la==TDantlrParser.K_MONTH or ((((_la - 159)) & ~0x3f) == 0 and ((1 << (_la - 159)) & ((1 << (TDantlrParser.K_HOUR - 159)) | (1 << (TDantlrParser.K_TIMEZONE_HOUR - 159)) | (1 << (TDantlrParser.K_DAY - 159)) | (1 << (TDantlrParser.K_TIMEZONE_MINUTE - 159)))) != 0) or _la==TDantlrParser.K_SECOND or _la==TDantlrParser.K_YEAR):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 473
            self.match(TDantlrParser.K_FROM)
            self.state = 474
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interval_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_INTERVAL(self):
            return self.getToken(TDantlrParser.K_INTERVAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(TDantlrParser.STRING_LITERAL, 0)

        def K_YEAR(self):
            return self.getToken(TDantlrParser.K_YEAR, 0)

        def K_MONTH(self):
            return self.getToken(TDantlrParser.K_MONTH, 0)

        def K_DAY(self):
            return self.getToken(TDantlrParser.K_DAY, 0)

        def K_HOUR(self):
            return self.getToken(TDantlrParser.K_HOUR, 0)

        def K_MINUTE(self):
            return self.getToken(TDantlrParser.K_MINUTE, 0)

        def K_SECOND(self):
            return self.getToken(TDantlrParser.K_SECOND, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_interval_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterval_expr" ):
                listener.enterInterval_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterval_expr" ):
                listener.exitInterval_expr(self)




    def interval_expr(self):

        localctx = TDantlrParser.Interval_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_interval_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self.match(TDantlrParser.K_INTERVAL)
            self.state = 477
            self.match(TDantlrParser.STRING_LITERAL)
            self.state = 478
            _la = self._input.LA(1)
            if not(_la==TDantlrParser.K_MINUTE or _la==TDantlrParser.K_MONTH or _la==TDantlrParser.K_HOUR or _la==TDantlrParser.K_DAY or _la==TDantlrParser.K_SECOND or _la==TDantlrParser.K_YEAR):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Analytical_function_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def analytical_function_name(self):
            return self.getTypedRuleContext(TDantlrParser.Analytical_function_nameContext,0)


        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.OPEN_PAR)
            else:
                return self.getToken(TDantlrParser.OPEN_PAR, i)

        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.CLOSE_PAR)
            else:
                return self.getToken(TDantlrParser.CLOSE_PAR, i)

        def K_OVER(self):
            return self.getToken(TDantlrParser.K_OVER, 0)

        def STAR(self):
            return self.getToken(TDantlrParser.STAR, 0)

        def expr_list(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_listContext,0)


        def K_PARTITION(self):
            return self.getToken(TDantlrParser.K_PARTITION, 0)

        def K_BY(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_BY)
            else:
                return self.getToken(TDantlrParser.K_BY, i)

        def partition_by_list(self):
            return self.getTypedRuleContext(TDantlrParser.Partition_by_listContext,0)


        def K_ORDER(self):
            return self.getToken(TDantlrParser.K_ORDER, 0)

        def order_by_list(self):
            return self.getTypedRuleContext(TDantlrParser.Order_by_listContext,0)


        def analytical_function_window(self):
            return self.getTypedRuleContext(TDantlrParser.Analytical_function_windowContext,0)


        def K_NULLS(self):
            return self.getToken(TDantlrParser.K_NULLS, 0)

        def K_FIRST(self):
            return self.getToken(TDantlrParser.K_FIRST, 0)

        def K_LAST(self):
            return self.getToken(TDantlrParser.K_LAST, 0)

        def K_ASC(self):
            return self.getToken(TDantlrParser.K_ASC, 0)

        def K_DESC(self):
            return self.getToken(TDantlrParser.K_DESC, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_analytical_function_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnalytical_function_expr" ):
                listener.enterAnalytical_function_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnalytical_function_expr" ):
                listener.exitAnalytical_function_expr(self)




    def analytical_function_expr(self):

        localctx = TDantlrParser.Analytical_function_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_analytical_function_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.analytical_function_name()
            self.state = 481
            self.match(TDantlrParser.OPEN_PAR)
            self.state = 484
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.STAR]:
                self.state = 482
                self.match(TDantlrParser.STAR)
                pass
            elif token in [TDantlrParser.OPEN_PAR, TDantlrParser.PLUS, TDantlrParser.MINUS, TDantlrParser.TILDE, TDantlrParser.K_MAX, TDantlrParser.K_CORR, TDantlrParser.K_MAXIMUM, TDantlrParser.K_ABS, TDantlrParser.K_COS, TDantlrParser.K_QUANTILE, TDantlrParser.K_STDDEV_POP, TDantlrParser.K_COSH, TDantlrParser.K_MDIFF, TDantlrParser.K_RADIANS, TDantlrParser.K_STDDEV_SAMP, TDantlrParser.K_ACCOUNT, TDantlrParser.K_COUNT, TDantlrParser.K_RANDOM, TDantlrParser.K_ACOS, TDantlrParser.K_COVAR_POP, TDantlrParser.K_MIN, TDantlrParser.K_RANGE_N, TDantlrParser.K_STRING_CS, TDantlrParser.K_ACOSH, TDantlrParser.K_COVAR_SAMP, TDantlrParser.K_RANK, TDantlrParser.K_MINIMUM, TDantlrParser.K_SUBSTR, TDantlrParser.K_ADD_MONTHS, TDantlrParser.K_SUBSTRING, TDantlrParser.K_MINUTE, TDantlrParser.K_SUM, TDantlrParser.K_CSUM, TDantlrParser.K_MLINREG, TDantlrParser.K_REGR_AVGX, TDantlrParser.K_REGR_AVGY, TDantlrParser.K_MOD, TDantlrParser.K_REGR_COUNT, TDantlrParser.K_CURRENT_DATE, TDantlrParser.K_REGR_INTERCEPT, TDantlrParser.K_TAN, TDantlrParser.K_CURRENT_TIME, TDantlrParser.K_REGR_R2, TDantlrParser.K_TANH, TDantlrParser.K_CURRENT_TIMESTAMP, TDantlrParser.K_REGR_SLOPE, TDantlrParser.K_REGR_SXX, TDantlrParser.K_REGR_SXY, TDantlrParser.K_MONTH, TDantlrParser.K_REGR_SYY, TDantlrParser.K_DATABASE, TDantlrParser.K_MSUM, TDantlrParser.K_TIME, TDantlrParser.K_ASIN, TDantlrParser.K_DATE, TDantlrParser.K_TIMESTAMP, TDantlrParser.K_ASINH, TDantlrParser.K_HOUR, TDantlrParser.K_TIMEZONE_HOUR, TDantlrParser.K_DAY, TDantlrParser.K_TIMEZONE_MINUTE, TDantlrParser.K_ATAN, TDantlrParser.K_TITLE, TDantlrParser.K_ATAN2, TDantlrParser.K_ATANH, TDantlrParser.K_DEFAULT, TDantlrParser.K_DEGREES, TDantlrParser.K_INDEX, TDantlrParser.K_TRANSLATE, TDantlrParser.K_NOT, TDantlrParser.K_TRANSLATE_CHK, TDantlrParser.K_AVG, TDantlrParser.K_NULL, TDantlrParser.K_TRIM, TDantlrParser.K_NULLIF, TDantlrParser.K_TYPE, TDantlrParser.K_NULLIFZERO, TDantlrParser.K_RIGHT, TDantlrParser.K_ROLE, TDantlrParser.K_OCTET_LENGTH, TDantlrParser.K_BYTE, TDantlrParser.K_INTERVAL, TDantlrParser.K_BYTES, TDantlrParser.K_ROW_NUMBER, TDantlrParser.K_UPPER, TDantlrParser.K_CASE, TDantlrParser.K_USER, TDantlrParser.K_CASE_N, TDantlrParser.K_SECOND, TDantlrParser.K_CAST, TDantlrParser.K_KURTOSIS, TDantlrParser.K_CHAR, TDantlrParser.K_SESSION, TDantlrParser.K_CHAR2HEXINT, TDantlrParser.K_VARGRAPHIC, TDantlrParser.K_CHARACTERS, TDantlrParser.K_VAR_POP, TDantlrParser.K_CHARACTER_LENGTH, TDantlrParser.K_LEFT, TDantlrParser.K_VAR_SAMP, TDantlrParser.K_CHARS, TDantlrParser.K_CHAR_LENGTH, TDantlrParser.K_SIN, TDantlrParser.K_LN, TDantlrParser.K_PERCENT_RANK, TDantlrParser.K_SINH, TDantlrParser.K_EXISTS, TDantlrParser.K_SKEW, TDantlrParser.K_EXP, TDantlrParser.K_POSITION, TDantlrParser.K_SOUNDEX, TDantlrParser.K_WIDTH_BUCKET, TDantlrParser.K_COALESCE, TDantlrParser.K_EXTRACT, TDantlrParser.K_LOG, TDantlrParser.K_YEAR, TDantlrParser.K_ZEROIFNULL, TDantlrParser.K_LOWER, TDantlrParser.K_PROFILE, TDantlrParser.K_SQRT, TDantlrParser.K_FORMAT, TDantlrParser.K_MAVG, TDantlrParser.K_LTRIM, TDantlrParser.K_RTRIM, TDantlrParser.K_LPAD, TDantlrParser.K_RPAD, TDantlrParser.K_CUME_DIST, TDantlrParser.K_DENSE_RANK, TDantlrParser.K_FIRST_VALUE, TDantlrParser.K_LAST_VALUE, TDantlrParser.K_MEDIAN, TDantlrParser.K_PERCENTILE_CON, TDantlrParser.K_PERCENTILE_DIS, TDantlrParser.K_CEILING, TDantlrParser.K_FLOOR, TDantlrParser.K_POWER, TDantlrParser.K_ROUND, TDantlrParser.K_SIGN, TDantlrParser.K_TRUNC, TDantlrParser.K_DEGREESRADIANS, TDantlrParser.K_NVL, TDantlrParser.K_NVL2, TDantlrParser.K_ASCII, TDantlrParser.K_CHR, TDantlrParser.K_CSVLD, TDantlrParser.K_EDITDISTANCE, TDantlrParser.K_INITCAP, TDantlrParser.K_INSTR, TDantlrParser.K_NGRAM, TDantlrParser.K_NVP, TDantlrParser.K_OREPLACE, TDantlrParser.K_OTRANSLATE, TDantlrParser.K_STRTOK, TDantlrParser.K_STRTOK_SPLIT_TO_TABLE, TDantlrParser.K_LENGTH, TDantlrParser.K_CSV, TDantlrParser.K_CURRENT_ROLE, TDantlrParser.K_CURRENT_USER, TDantlrParser.K_TEMPORAL_DATE, TDantlrParser.K_TEMPORAL_TIMESTAMP, TDantlrParser.K_BITAND, TDantlrParser.K_BITNOT, TDantlrParser.K_BITOR, TDantlrParser.K_BITXOR, TDantlrParser.K_COUNTSET, TDantlrParser.K_GETBIT, TDantlrParser.K_ROTATELEFT, TDantlrParser.K_ROTATERIGHT, TDantlrParser.K_SETBIT, TDantlrParser.K_SHIFTLEFT, TDantlrParser.K_SHIFTRIGHT, TDantlrParser.K_SUBBITSTR, TDantlrParser.K_TO_BYTE, TDantlrParser.K_TO_CHAR, TDantlrParser.K_TO_DATE, TDantlrParser.K_TO_TIMESTAMP, TDantlrParser.K_TO_NUMBER, TDantlrParser.K_OADD_MONTHS, TDantlrParser.K_GROUPING, TDantlrParser.K_CEIL, TDantlrParser.K_GREATEST, TDantlrParser.K_LEAST, TDantlrParser.K_LAST_DAY, TDantlrParser.K_NEXT_DAY, TDantlrParser.K_MONTHS_BETWEEN, TDantlrParser.K_REVERSE, TDantlrParser.K_TD_DAY_OF_WEEK, TDantlrParser.K_TD_DAY_OF_MONTH, TDantlrParser.K_TD_DAY_OF_YEAR, TDantlrParser.K_TD_WEEK_OF_YEAR, TDantlrParser.K_TD_MONTH_OF_QUARTER, TDantlrParser.K_TD_MONTH_OF_YEAR, TDantlrParser.K_TD_QUARTER_OF_YEAR, TDantlrParser.NUMERIC_LITERAL, TDantlrParser.IDENTIFIER, TDantlrParser.STRING_LITERAL]:
                self.state = 483
                self.expr_list()
                pass
            elif token in [TDantlrParser.CLOSE_PAR]:
                pass
            else:
                pass
            self.state = 486
            self.match(TDantlrParser.CLOSE_PAR)
            self.state = 487
            self.match(TDantlrParser.K_OVER)
            self.state = 488
            self.match(TDantlrParser.OPEN_PAR)
            self.state = 492
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_PARTITION:
                self.state = 489
                self.match(TDantlrParser.K_PARTITION)
                self.state = 490
                self.match(TDantlrParser.K_BY)
                self.state = 491
                self.partition_by_list()


            self.state = 506
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_ORDER:
                self.state = 494
                self.match(TDantlrParser.K_ORDER)
                self.state = 495
                self.match(TDantlrParser.K_BY)
                self.state = 496
                self.order_by_list()
                self.state = 498
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC:
                    self.state = 497
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 504
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
                if la_ == 1:
                    self.state = 500
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 501
                    self.match(TDantlrParser.K_FIRST)

                elif la_ == 2:
                    self.state = 502
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 503
                    self.match(TDantlrParser.K_LAST)




            self.state = 509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_ROWS:
                self.state = 508
                self.analytical_function_window()


            self.state = 511
            self.match(TDantlrParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_by_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def group_by_val(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.Group_by_valContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.Group_by_valContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_partition_by_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_by_list" ):
                listener.enterPartition_by_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_by_list" ):
                listener.exitPartition_by_list(self)




    def partition_by_list(self):

        localctx = TDantlrParser.Partition_by_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_partition_by_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 513
            self.group_by_val()
            self.state = 518
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TDantlrParser.COMMA:
                self.state = 514
                self.match(TDantlrParser.COMMA)
                self.state = 515
                self.group_by_val()
                self.state = 520
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Analytical_function_windowContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ROWS(self):
            return self.getToken(TDantlrParser.K_ROWS, 0)

        def window_bound(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.Window_boundContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.Window_boundContext,i)


        def K_BETWEEN(self):
            return self.getToken(TDantlrParser.K_BETWEEN, 0)

        def K_AND(self):
            return self.getToken(TDantlrParser.K_AND, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_analytical_function_window

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnalytical_function_window" ):
                listener.enterAnalytical_function_window(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnalytical_function_window" ):
                listener.exitAnalytical_function_window(self)




    def analytical_function_window(self):

        localctx = TDantlrParser.Analytical_function_windowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_analytical_function_window)
        try:
            self.state = 529
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 521
                self.match(TDantlrParser.K_ROWS)
                self.state = 522
                self.window_bound()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 523
                self.match(TDantlrParser.K_ROWS)
                self.state = 524
                self.match(TDantlrParser.K_BETWEEN)
                self.state = 525
                self.window_bound()
                self.state = 526
                self.match(TDantlrParser.K_AND)
                self.state = 527
                self.window_bound()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Window_boundContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_UNBOUNDED(self):
            return self.getToken(TDantlrParser.K_UNBOUNDED, 0)

        def K_FOLLOWING(self):
            return self.getToken(TDantlrParser.K_FOLLOWING, 0)

        def K_PRECEDING(self):
            return self.getToken(TDantlrParser.K_PRECEDING, 0)

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)


        def K_CURRENT(self):
            return self.getToken(TDantlrParser.K_CURRENT, 0)

        def K_ROW(self):
            return self.getToken(TDantlrParser.K_ROW, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_window_bound

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindow_bound" ):
                listener.enterWindow_bound(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindow_bound" ):
                listener.exitWindow_bound(self)




    def window_bound(self):

        localctx = TDantlrParser.Window_boundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_window_bound)
        self._la = 0 # Token type
        try:
            self.state = 538
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.K_UNBOUNDED]:
                self.enterOuterAlt(localctx, 1)
                self.state = 531
                self.match(TDantlrParser.K_UNBOUNDED)
                self.state = 532
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_FOLLOWING or _la==TDantlrParser.K_PRECEDING):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [TDantlrParser.OPEN_PAR, TDantlrParser.PLUS, TDantlrParser.MINUS, TDantlrParser.TILDE, TDantlrParser.K_MAX, TDantlrParser.K_CORR, TDantlrParser.K_MAXIMUM, TDantlrParser.K_ABS, TDantlrParser.K_COS, TDantlrParser.K_QUANTILE, TDantlrParser.K_STDDEV_POP, TDantlrParser.K_COSH, TDantlrParser.K_MDIFF, TDantlrParser.K_RADIANS, TDantlrParser.K_STDDEV_SAMP, TDantlrParser.K_ACCOUNT, TDantlrParser.K_COUNT, TDantlrParser.K_RANDOM, TDantlrParser.K_ACOS, TDantlrParser.K_COVAR_POP, TDantlrParser.K_MIN, TDantlrParser.K_RANGE_N, TDantlrParser.K_STRING_CS, TDantlrParser.K_ACOSH, TDantlrParser.K_COVAR_SAMP, TDantlrParser.K_RANK, TDantlrParser.K_MINIMUM, TDantlrParser.K_SUBSTR, TDantlrParser.K_ADD_MONTHS, TDantlrParser.K_SUBSTRING, TDantlrParser.K_MINUTE, TDantlrParser.K_SUM, TDantlrParser.K_CSUM, TDantlrParser.K_MLINREG, TDantlrParser.K_REGR_AVGX, TDantlrParser.K_REGR_AVGY, TDantlrParser.K_MOD, TDantlrParser.K_REGR_COUNT, TDantlrParser.K_CURRENT_DATE, TDantlrParser.K_REGR_INTERCEPT, TDantlrParser.K_TAN, TDantlrParser.K_CURRENT_TIME, TDantlrParser.K_REGR_R2, TDantlrParser.K_TANH, TDantlrParser.K_CURRENT_TIMESTAMP, TDantlrParser.K_REGR_SLOPE, TDantlrParser.K_REGR_SXX, TDantlrParser.K_REGR_SXY, TDantlrParser.K_MONTH, TDantlrParser.K_REGR_SYY, TDantlrParser.K_DATABASE, TDantlrParser.K_MSUM, TDantlrParser.K_TIME, TDantlrParser.K_ASIN, TDantlrParser.K_DATE, TDantlrParser.K_TIMESTAMP, TDantlrParser.K_ASINH, TDantlrParser.K_HOUR, TDantlrParser.K_TIMEZONE_HOUR, TDantlrParser.K_DAY, TDantlrParser.K_TIMEZONE_MINUTE, TDantlrParser.K_ATAN, TDantlrParser.K_TITLE, TDantlrParser.K_ATAN2, TDantlrParser.K_ATANH, TDantlrParser.K_DEFAULT, TDantlrParser.K_DEGREES, TDantlrParser.K_INDEX, TDantlrParser.K_TRANSLATE, TDantlrParser.K_NOT, TDantlrParser.K_TRANSLATE_CHK, TDantlrParser.K_AVG, TDantlrParser.K_NULL, TDantlrParser.K_TRIM, TDantlrParser.K_NULLIF, TDantlrParser.K_TYPE, TDantlrParser.K_NULLIFZERO, TDantlrParser.K_RIGHT, TDantlrParser.K_ROLE, TDantlrParser.K_OCTET_LENGTH, TDantlrParser.K_BYTE, TDantlrParser.K_INTERVAL, TDantlrParser.K_BYTES, TDantlrParser.K_ROW_NUMBER, TDantlrParser.K_UPPER, TDantlrParser.K_CASE, TDantlrParser.K_USER, TDantlrParser.K_CASE_N, TDantlrParser.K_SECOND, TDantlrParser.K_CAST, TDantlrParser.K_KURTOSIS, TDantlrParser.K_CHAR, TDantlrParser.K_SESSION, TDantlrParser.K_CHAR2HEXINT, TDantlrParser.K_VARGRAPHIC, TDantlrParser.K_CHARACTERS, TDantlrParser.K_VAR_POP, TDantlrParser.K_CHARACTER_LENGTH, TDantlrParser.K_LEFT, TDantlrParser.K_VAR_SAMP, TDantlrParser.K_CHARS, TDantlrParser.K_CHAR_LENGTH, TDantlrParser.K_SIN, TDantlrParser.K_LN, TDantlrParser.K_PERCENT_RANK, TDantlrParser.K_SINH, TDantlrParser.K_EXISTS, TDantlrParser.K_SKEW, TDantlrParser.K_EXP, TDantlrParser.K_POSITION, TDantlrParser.K_SOUNDEX, TDantlrParser.K_WIDTH_BUCKET, TDantlrParser.K_COALESCE, TDantlrParser.K_EXTRACT, TDantlrParser.K_LOG, TDantlrParser.K_YEAR, TDantlrParser.K_ZEROIFNULL, TDantlrParser.K_LOWER, TDantlrParser.K_PROFILE, TDantlrParser.K_SQRT, TDantlrParser.K_FORMAT, TDantlrParser.K_MAVG, TDantlrParser.K_LTRIM, TDantlrParser.K_RTRIM, TDantlrParser.K_LPAD, TDantlrParser.K_RPAD, TDantlrParser.K_CUME_DIST, TDantlrParser.K_DENSE_RANK, TDantlrParser.K_FIRST_VALUE, TDantlrParser.K_LAST_VALUE, TDantlrParser.K_MEDIAN, TDantlrParser.K_PERCENTILE_CON, TDantlrParser.K_PERCENTILE_DIS, TDantlrParser.K_CEILING, TDantlrParser.K_FLOOR, TDantlrParser.K_POWER, TDantlrParser.K_ROUND, TDantlrParser.K_SIGN, TDantlrParser.K_TRUNC, TDantlrParser.K_DEGREESRADIANS, TDantlrParser.K_NVL, TDantlrParser.K_NVL2, TDantlrParser.K_ASCII, TDantlrParser.K_CHR, TDantlrParser.K_CSVLD, TDantlrParser.K_EDITDISTANCE, TDantlrParser.K_INITCAP, TDantlrParser.K_INSTR, TDantlrParser.K_NGRAM, TDantlrParser.K_NVP, TDantlrParser.K_OREPLACE, TDantlrParser.K_OTRANSLATE, TDantlrParser.K_STRTOK, TDantlrParser.K_STRTOK_SPLIT_TO_TABLE, TDantlrParser.K_LENGTH, TDantlrParser.K_CSV, TDantlrParser.K_CURRENT_ROLE, TDantlrParser.K_CURRENT_USER, TDantlrParser.K_TEMPORAL_DATE, TDantlrParser.K_TEMPORAL_TIMESTAMP, TDantlrParser.K_BITAND, TDantlrParser.K_BITNOT, TDantlrParser.K_BITOR, TDantlrParser.K_BITXOR, TDantlrParser.K_COUNTSET, TDantlrParser.K_GETBIT, TDantlrParser.K_ROTATELEFT, TDantlrParser.K_ROTATERIGHT, TDantlrParser.K_SETBIT, TDantlrParser.K_SHIFTLEFT, TDantlrParser.K_SHIFTRIGHT, TDantlrParser.K_SUBBITSTR, TDantlrParser.K_TO_BYTE, TDantlrParser.K_TO_CHAR, TDantlrParser.K_TO_DATE, TDantlrParser.K_TO_TIMESTAMP, TDantlrParser.K_TO_NUMBER, TDantlrParser.K_OADD_MONTHS, TDantlrParser.K_GROUPING, TDantlrParser.K_CEIL, TDantlrParser.K_GREATEST, TDantlrParser.K_LEAST, TDantlrParser.K_LAST_DAY, TDantlrParser.K_NEXT_DAY, TDantlrParser.K_MONTHS_BETWEEN, TDantlrParser.K_REVERSE, TDantlrParser.K_TD_DAY_OF_WEEK, TDantlrParser.K_TD_DAY_OF_MONTH, TDantlrParser.K_TD_DAY_OF_YEAR, TDantlrParser.K_TD_WEEK_OF_YEAR, TDantlrParser.K_TD_MONTH_OF_QUARTER, TDantlrParser.K_TD_MONTH_OF_YEAR, TDantlrParser.K_TD_QUARTER_OF_YEAR, TDantlrParser.NUMERIC_LITERAL, TDantlrParser.IDENTIFIER, TDantlrParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 533
                self.expr(0)
                self.state = 534
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_FOLLOWING or _la==TDantlrParser.K_PRECEDING):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [TDantlrParser.K_CURRENT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 536
                self.match(TDantlrParser.K_CURRENT)
                self.state = 537
                self.match(TDantlrParser.K_ROW)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FROM(self):
            return self.getToken(TDantlrParser.K_FROM, 0)

        def from_expr(self):
            return self.getTypedRuleContext(TDantlrParser.From_exprContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_from_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_clause" ):
                listener.enterFrom_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_clause" ):
                listener.exitFrom_clause(self)




    def from_clause(self):

        localctx = TDantlrParser.From_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_from_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.match(TDantlrParser.K_FROM)
            self.state = 541
            self.from_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def from_table_expr(self):
            return self.getTypedRuleContext(TDantlrParser.From_table_exprContext,0)


        def from_join_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.From_join_exprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.From_join_exprContext,i)


        def getRuleIndex(self):
            return TDantlrParser.RULE_from_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_expr" ):
                listener.enterFrom_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_expr" ):
                listener.exitFrom_expr(self)




    def from_expr(self):

        localctx = TDantlrParser.From_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_from_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self.from_table_expr()
            self.state = 547
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,65,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 544
                    self.from_join_expr() 
                self.state = 549
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,65,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_table_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def from_single_expr(self):
            return self.getTypedRuleContext(TDantlrParser.From_single_exprContext,0)


        def from_derived_expr(self):
            return self.getTypedRuleContext(TDantlrParser.From_derived_exprContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_from_table_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_table_expr" ):
                listener.enterFrom_table_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_table_expr" ):
                listener.exitFrom_table_expr(self)




    def from_table_expr(self):

        localctx = TDantlrParser.From_table_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_from_table_expr)
        try:
            self.state = 552
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 550
                self.from_single_expr()
                pass
            elif token in [TDantlrParser.OPEN_PAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 551
                self.from_derived_expr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_single_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def correlation_name(self):
            return self.getTypedRuleContext(TDantlrParser.Correlation_nameContext,0)


        def K_AS(self):
            return self.getToken(TDantlrParser.K_AS, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_from_single_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_single_expr" ):
                listener.enterFrom_single_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_single_expr" ):
                listener.exitFrom_single_expr(self)




    def from_single_expr(self):

        localctx = TDantlrParser.From_single_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_from_single_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self.table_name()
            self.state = 559
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                self.state = 556
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_AS:
                    self.state = 555
                    self.match(TDantlrParser.K_AS)


                self.state = 558
                self.correlation_name()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_derived_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.OPEN_PAR)
            else:
                return self.getToken(TDantlrParser.OPEN_PAR, i)

        def subquery(self):
            return self.getTypedRuleContext(TDantlrParser.SubqueryContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.CLOSE_PAR)
            else:
                return self.getToken(TDantlrParser.CLOSE_PAR, i)

        def derived_table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Derived_table_nameContext,0)


        def K_AS(self):
            return self.getToken(TDantlrParser.K_AS, 0)

        def column_list(self):
            return self.getTypedRuleContext(TDantlrParser.Column_listContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_from_derived_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_derived_expr" ):
                listener.enterFrom_derived_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_derived_expr" ):
                listener.exitFrom_derived_expr(self)




    def from_derived_expr(self):

        localctx = TDantlrParser.From_derived_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_from_derived_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 561
            self.match(TDantlrParser.OPEN_PAR)
            self.state = 562
            self.subquery()
            self.state = 563
            self.match(TDantlrParser.CLOSE_PAR)
            self.state = 565
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_AS:
                self.state = 564
                self.match(TDantlrParser.K_AS)


            self.state = 567
            self.derived_table_name()
            self.state = 572
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 568
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 569
                self.column_list()
                self.state = 570
                self.match(TDantlrParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_join_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_JOIN(self):
            return self.getToken(TDantlrParser.K_JOIN, 0)

        def from_table_expr(self):
            return self.getTypedRuleContext(TDantlrParser.From_table_exprContext,0)


        def K_ON(self):
            return self.getToken(TDantlrParser.K_ON, 0)

        def search_condition(self):
            return self.getTypedRuleContext(TDantlrParser.Search_conditionContext,0)


        def K_INNER(self):
            return self.getToken(TDantlrParser.K_INNER, 0)

        def K_LEFT(self):
            return self.getToken(TDantlrParser.K_LEFT, 0)

        def K_RIGHT(self):
            return self.getToken(TDantlrParser.K_RIGHT, 0)

        def K_FULL(self):
            return self.getToken(TDantlrParser.K_FULL, 0)

        def K_OUTER(self):
            return self.getToken(TDantlrParser.K_OUTER, 0)

        def K_CROSS(self):
            return self.getToken(TDantlrParser.K_CROSS, 0)

        def COMMA(self):
            return self.getToken(TDantlrParser.COMMA, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_from_join_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_join_expr" ):
                listener.enterFrom_join_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_join_expr" ):
                listener.exitFrom_join_expr(self)




    def from_join_expr(self):

        localctx = TDantlrParser.From_join_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_from_join_expr)
        self._la = 0 # Token type
        try:
            self.state = 591
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.K_FULL, TDantlrParser.K_INNER, TDantlrParser.K_RIGHT, TDantlrParser.K_JOIN, TDantlrParser.K_LEFT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 579
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [TDantlrParser.K_INNER]:
                    self.state = 574
                    self.match(TDantlrParser.K_INNER)
                    pass
                elif token in [TDantlrParser.K_FULL, TDantlrParser.K_RIGHT, TDantlrParser.K_LEFT]:
                    self.state = 575
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.K_FULL or _la==TDantlrParser.K_RIGHT or _la==TDantlrParser.K_LEFT):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 577
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==TDantlrParser.K_OUTER:
                        self.state = 576
                        self.match(TDantlrParser.K_OUTER)


                    pass
                elif token in [TDantlrParser.K_JOIN]:
                    pass
                else:
                    pass
                self.state = 581
                self.match(TDantlrParser.K_JOIN)
                self.state = 582
                self.from_table_expr()
                self.state = 583
                self.match(TDantlrParser.K_ON)
                self.state = 584
                self.search_condition()
                pass
            elif token in [TDantlrParser.K_CROSS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 586
                self.match(TDantlrParser.K_CROSS)
                self.state = 587
                self.match(TDantlrParser.K_JOIN)
                self.state = 588
                self.from_table_expr()
                pass
            elif token in [TDantlrParser.COMMA]:
                self.enterOuterAlt(localctx, 3)
                self.state = 589
                self.match(TDantlrParser.COMMA)
                self.state = 590
                self.from_table_expr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_with_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WITH(self):
            return self.getToken(TDantlrParser.K_WITH, 0)

        def expr_list(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_listContext,0)


        def K_BY(self):
            return self.getToken(TDantlrParser.K_BY, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.ExprContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)

        def K_ASC(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_ASC)
            else:
                return self.getToken(TDantlrParser.K_ASC, i)

        def K_DESC(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.K_DESC)
            else:
                return self.getToken(TDantlrParser.K_DESC, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_from_with_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_with_expr" ):
                listener.enterFrom_with_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_with_expr" ):
                listener.exitFrom_with_expr(self)




    def from_with_expr(self):

        localctx = TDantlrParser.From_with_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_from_with_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.match(TDantlrParser.K_WITH)
            self.state = 594
            self.expr_list()
            self.state = 610
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
            if la_ == 1:
                self.state = 595
                self.match(TDantlrParser.K_BY)
                self.state = 596
                self.expr(0)
                self.state = 598
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                if la_ == 1:
                    self.state = 597
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 607
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,76,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 600
                        self.match(TDantlrParser.COMMA)
                        self.state = 601
                        self.expr(0)
                        self.state = 603
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                        if la_ == 1:
                            self.state = 602
                            _la = self._input.LA(1)
                            if not(_la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()

                 
                    self.state = 609
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,76,self._ctx)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Where_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WHERE(self):
            return self.getToken(TDantlrParser.K_WHERE, 0)

        def search_condition(self):
            return self.getTypedRuleContext(TDantlrParser.Search_conditionContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_where_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhere_clause" ):
                listener.enterWhere_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhere_clause" ):
                listener.exitWhere_clause(self)




    def where_clause(self):

        localctx = TDantlrParser.Where_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_where_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 612
            self.match(TDantlrParser.K_WHERE)
            self.state = 613
            self.search_condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Having_qualify_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def having_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Having_exprContext,0)


        def qualify_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Qualify_exprContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_having_qualify_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHaving_qualify_expr" ):
                listener.enterHaving_qualify_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHaving_qualify_expr" ):
                listener.exitHaving_qualify_expr(self)




    def having_qualify_expr(self):

        localctx = TDantlrParser.Having_qualify_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_having_qualify_expr)
        try:
            self.state = 617
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.K_HAVING]:
                self.enterOuterAlt(localctx, 1)
                self.state = 615
                self.having_expr()
                pass
            elif token in [TDantlrParser.K_QUALIFY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 616
                self.qualify_expr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Having_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_HAVING(self):
            return self.getToken(TDantlrParser.K_HAVING, 0)

        def conditional_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Conditional_exprContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_having_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHaving_expr" ):
                listener.enterHaving_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHaving_expr" ):
                listener.exitHaving_expr(self)




    def having_expr(self):

        localctx = TDantlrParser.Having_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_having_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 619
            self.match(TDantlrParser.K_HAVING)
            self.state = 620
            self.conditional_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Qualify_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_QUALIFY(self):
            return self.getToken(TDantlrParser.K_QUALIFY, 0)

        def search_condition(self):
            return self.getTypedRuleContext(TDantlrParser.Search_conditionContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_qualify_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualify_expr" ):
                listener.enterQualify_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualify_expr" ):
                listener.exitQualify_expr(self)




    def qualify_expr(self):

        localctx = TDantlrParser.Qualify_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_qualify_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            self.match(TDantlrParser.K_QUALIFY)
            self.state = 623
            self.search_condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_by_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def group_by_val(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.Group_by_valContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.Group_by_valContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_group_by_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_by_list" ):
                listener.enterGroup_by_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_by_list" ):
                listener.exitGroup_by_list(self)




    def group_by_list(self):

        localctx = TDantlrParser.Group_by_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_group_by_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 625
            self.group_by_val()
            self.state = 630
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,79,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 626
                    self.match(TDantlrParser.COMMA)
                    self.state = 627
                    self.group_by_val() 
                self.state = 632
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,79,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_by_valContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ordinary_grouping_set(self):
            return self.getTypedRuleContext(TDantlrParser.Ordinary_grouping_setContext,0)


        def empty_grouping_set(self):
            return self.getTypedRuleContext(TDantlrParser.Empty_grouping_setContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_group_by_val

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_by_val" ):
                listener.enterGroup_by_val(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_by_val" ):
                listener.exitGroup_by_val(self)




    def group_by_val(self):

        localctx = TDantlrParser.Group_by_valContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_group_by_val)
        try:
            self.state = 635
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 633
                self.ordinary_grouping_set()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 634
                self.empty_grouping_set()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def order_by_val(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.Order_by_valContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.Order_by_valContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_order_by_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder_by_list" ):
                listener.enterOrder_by_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder_by_list" ):
                listener.exitOrder_by_list(self)




    def order_by_list(self):

        localctx = TDantlrParser.Order_by_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_order_by_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 637
            self.order_by_val()
            self.state = 642
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,81,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 638
                    self.match(TDantlrParser.COMMA)
                    self.state = 639
                    self.order_by_val() 
                self.state = 644
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,81,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_valContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)


        def K_NULLS(self):
            return self.getToken(TDantlrParser.K_NULLS, 0)

        def K_FIRST(self):
            return self.getToken(TDantlrParser.K_FIRST, 0)

        def K_LAST(self):
            return self.getToken(TDantlrParser.K_LAST, 0)

        def K_ASC(self):
            return self.getToken(TDantlrParser.K_ASC, 0)

        def K_DESC(self):
            return self.getToken(TDantlrParser.K_DESC, 0)

        def column_name(self):
            return self.getTypedRuleContext(TDantlrParser.Column_nameContext,0)


        def column_alias(self):
            return self.getTypedRuleContext(TDantlrParser.Column_aliasContext,0)


        def column_position(self):
            return self.getTypedRuleContext(TDantlrParser.Column_positionContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_order_by_val

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder_by_val" ):
                listener.enterOrder_by_val(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder_by_val" ):
                listener.exitOrder_by_val(self)




    def order_by_val(self):

        localctx = TDantlrParser.Order_by_valContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_order_by_val)
        self._la = 0 # Token type
        try:
            self.state = 685
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 645
                self.expr(0)
                self.state = 647
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                if la_ == 1:
                    self.state = 646
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 653
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                if la_ == 1:
                    self.state = 649
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 650
                    self.match(TDantlrParser.K_FIRST)

                elif la_ == 2:
                    self.state = 651
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 652
                    self.match(TDantlrParser.K_LAST)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 655
                self.column_name()
                self.state = 657
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                if la_ == 1:
                    self.state = 656
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 663
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                if la_ == 1:
                    self.state = 659
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 660
                    self.match(TDantlrParser.K_FIRST)

                elif la_ == 2:
                    self.state = 661
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 662
                    self.match(TDantlrParser.K_LAST)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 665
                self.column_alias()
                self.state = 667
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                if la_ == 1:
                    self.state = 666
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 673
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                if la_ == 1:
                    self.state = 669
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 670
                    self.match(TDantlrParser.K_FIRST)

                elif la_ == 2:
                    self.state = 671
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 672
                    self.match(TDantlrParser.K_LAST)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 675
                self.column_position()
                self.state = 677
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
                if la_ == 1:
                    self.state = 676
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.K_ASC or _la==TDantlrParser.K_DESC):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 683
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
                if la_ == 1:
                    self.state = 679
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 680
                    self.match(TDantlrParser.K_FIRST)

                elif la_ == 2:
                    self.state = 681
                    self.match(TDantlrParser.K_NULLS)
                    self.state = 682
                    self.match(TDantlrParser.K_LAST)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ordinary_grouping_setContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self):
            return self.getTypedRuleContext(TDantlrParser.Column_nameContext,0)


        def column_position(self):
            return self.getTypedRuleContext(TDantlrParser.Column_positionContext,0)


        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_ordinary_grouping_set

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrdinary_grouping_set" ):
                listener.enterOrdinary_grouping_set(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrdinary_grouping_set" ):
                listener.exitOrdinary_grouping_set(self)




    def ordinary_grouping_set(self):

        localctx = TDantlrParser.Ordinary_grouping_setContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_ordinary_grouping_set)
        try:
            self.state = 690
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 687
                self.column_name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 688
                self.column_position()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 689
                self.expr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Empty_grouping_setContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_empty_grouping_set

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmpty_grouping_set" ):
                listener.enterEmpty_grouping_set(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmpty_grouping_set" ):
                listener.exitEmpty_grouping_set(self)




    def empty_grouping_set(self):

        localctx = TDantlrParser.Empty_grouping_setContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_empty_grouping_set)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.match(TDantlrParser.OPEN_PAR)
            self.state = 693
            self.match(TDantlrParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.OPEN_PAR)
            else:
                return self.getToken(TDantlrParser.OPEN_PAR, i)

        def expr_list(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_listContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.CLOSE_PAR)
            else:
                return self.getToken(TDantlrParser.CLOSE_PAR, i)

        def K_INSERT(self):
            return self.getToken(TDantlrParser.K_INSERT, 0)

        def K_INS(self):
            return self.getToken(TDantlrParser.K_INS, 0)

        def K_INTO(self):
            return self.getToken(TDantlrParser.K_INTO, 0)

        def column_list(self):
            return self.getTypedRuleContext(TDantlrParser.Column_listContext,0)


        def K_VALUES(self):
            return self.getToken(TDantlrParser.K_VALUES, 0)

        def subquery(self):
            return self.getTypedRuleContext(TDantlrParser.SubqueryContext,0)


        def insert_logging_errors(self):
            return self.getTypedRuleContext(TDantlrParser.Insert_logging_errorsContext,0)


        def K_DEFAULT(self):
            return self.getToken(TDantlrParser.K_DEFAULT, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_insert_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_statement" ):
                listener.enterInsert_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_statement" ):
                listener.exitInsert_statement(self)




    def insert_statement(self):

        localctx = TDantlrParser.Insert_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_insert_statement)
        self._la = 0 # Token type
        try:
            self.state = 742
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 695
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_INS or _la==TDantlrParser.K_INSERT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 697
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_INTO:
                    self.state = 696
                    self.match(TDantlrParser.K_INTO)


                self.state = 699
                self.table_name()
                self.state = 701
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
                if la_ == 1:
                    self.state = 700
                    self.match(TDantlrParser.OPEN_PAR)


                self.state = 704
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.IDENTIFIER:
                    self.state = 703
                    self.column_list()


                self.state = 707
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.CLOSE_PAR:
                    self.state = 706
                    self.match(TDantlrParser.CLOSE_PAR)


                self.state = 710
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_VALUES:
                    self.state = 709
                    self.match(TDantlrParser.K_VALUES)


                self.state = 712
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 713
                self.expr_list()
                self.state = 714
                self.match(TDantlrParser.CLOSE_PAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 716
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_INS or _la==TDantlrParser.K_INSERT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 718
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_INTO:
                    self.state = 717
                    self.match(TDantlrParser.K_INTO)


                self.state = 720
                self.table_name()
                self.state = 722
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.OPEN_PAR:
                    self.state = 721
                    self.match(TDantlrParser.OPEN_PAR)


                self.state = 725
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.IDENTIFIER:
                    self.state = 724
                    self.column_list()


                self.state = 728
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.CLOSE_PAR:
                    self.state = 727
                    self.match(TDantlrParser.CLOSE_PAR)


                self.state = 730
                self.subquery()
                self.state = 732
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_LOGGING:
                    self.state = 731
                    self.insert_logging_errors()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 734
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_INS or _la==TDantlrParser.K_INSERT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 736
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_INTO:
                    self.state = 735
                    self.match(TDantlrParser.K_INTO)


                self.state = 738
                self.table_name()
                self.state = 739
                self.match(TDantlrParser.K_DEFAULT)
                self.state = 740
                self.match(TDantlrParser.K_VALUES)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_logging_errorsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_LOGGING(self):
            return self.getToken(TDantlrParser.K_LOGGING, 0)

        def K_ERRORS(self):
            return self.getToken(TDantlrParser.K_ERRORS, 0)

        def K_ALL(self):
            return self.getToken(TDantlrParser.K_ALL, 0)

        def K_WITH(self):
            return self.getToken(TDantlrParser.K_WITH, 0)

        def K_NO(self):
            return self.getToken(TDantlrParser.K_NO, 0)

        def K_LIMIT(self):
            return self.getToken(TDantlrParser.K_LIMIT, 0)

        def K_OF(self):
            return self.getToken(TDantlrParser.K_OF, 0)

        def NUMERIC_LITERAL(self):
            return self.getToken(TDantlrParser.NUMERIC_LITERAL, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_insert_logging_errors

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_logging_errors" ):
                listener.enterInsert_logging_errors(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_logging_errors" ):
                listener.exitInsert_logging_errors(self)




    def insert_logging_errors(self):

        localctx = TDantlrParser.Insert_logging_errorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_insert_logging_errors)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            self.match(TDantlrParser.K_LOGGING)
            self.state = 746
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_ALL:
                self.state = 745
                self.match(TDantlrParser.K_ALL)


            self.state = 748
            self.match(TDantlrParser.K_ERRORS)
            self.state = 757
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_WITH:
                self.state = 749
                self.match(TDantlrParser.K_WITH)
                self.state = 755
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [TDantlrParser.K_NO]:
                    self.state = 750
                    self.match(TDantlrParser.K_NO)
                    self.state = 751
                    self.match(TDantlrParser.K_LIMIT)
                    pass
                elif token in [TDantlrParser.K_LIMIT]:
                    self.state = 752
                    self.match(TDantlrParser.K_LIMIT)
                    self.state = 753
                    self.match(TDantlrParser.K_OF)
                    self.state = 754
                    self.match(TDantlrParser.NUMERIC_LITERAL)
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delete_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DELETE(self):
            return self.getToken(TDantlrParser.K_DELETE, 0)

        def K_DEL(self):
            return self.getToken(TDantlrParser.K_DEL, 0)

        def correlation_name(self):
            return self.getTypedRuleContext(TDantlrParser.Correlation_nameContext,0)


        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def from_clause(self):
            return self.getTypedRuleContext(TDantlrParser.From_clauseContext,0)


        def where_clause(self):
            return self.getTypedRuleContext(TDantlrParser.Where_clauseContext,0)


        def K_ALL(self):
            return self.getToken(TDantlrParser.K_ALL, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_delete_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelete_statement" ):
                listener.enterDelete_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelete_statement" ):
                listener.exitDelete_statement(self)




    def delete_statement(self):

        localctx = TDantlrParser.Delete_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_delete_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 759
            _la = self._input.LA(1)
            if not(_la==TDantlrParser.K_DEL or _la==TDantlrParser.K_DELETE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 762
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
            if la_ == 1:
                self.state = 760
                self.correlation_name()

            elif la_ == 2:
                self.state = 761
                self.table_name()


            self.state = 765
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_FROM:
                self.state = 764
                self.from_clause()


            self.state = 769
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.K_WHERE]:
                self.state = 767
                self.where_clause()
                pass
            elif token in [TDantlrParser.K_ALL]:
                self.state = 768
                self.match(TDantlrParser.K_ALL)
                pass
            elif token in [TDantlrParser.EOF, TDantlrParser.SCOL]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def K_SET(self):
            return self.getToken(TDantlrParser.K_SET, 0)

        def update_set(self):
            return self.getTypedRuleContext(TDantlrParser.Update_setContext,0)


        def K_UPDATE(self):
            return self.getToken(TDantlrParser.K_UPDATE, 0)

        def K_UPD(self):
            return self.getToken(TDantlrParser.K_UPD, 0)

        def where_clause(self):
            return self.getTypedRuleContext(TDantlrParser.Where_clauseContext,0)


        def K_ALL(self):
            return self.getToken(TDantlrParser.K_ALL, 0)

        def from_clause(self):
            return self.getTypedRuleContext(TDantlrParser.From_clauseContext,0)


        def correlation_name(self):
            return self.getTypedRuleContext(TDantlrParser.Correlation_nameContext,0)


        def K_ELSE(self):
            return self.getToken(TDantlrParser.K_ELSE, 0)

        def insert_statement(self):
            return self.getTypedRuleContext(TDantlrParser.Insert_statementContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_update_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdate_statement" ):
                listener.enterUpdate_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdate_statement" ):
                listener.exitUpdate_statement(self)




    def update_statement(self):

        localctx = TDantlrParser.Update_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_update_statement)
        self._la = 0 # Token type
        try:
            self.state = 799
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,113,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 771
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_UPD or _la==TDantlrParser.K_UPDATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 772
                self.table_name()
                self.state = 773
                self.match(TDantlrParser.K_SET)
                self.state = 774
                self.update_set()
                self.state = 777
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [TDantlrParser.K_WHERE]:
                    self.state = 775
                    self.where_clause()
                    pass
                elif token in [TDantlrParser.K_ALL]:
                    self.state = 776
                    self.match(TDantlrParser.K_ALL)
                    pass
                elif token in [TDantlrParser.EOF, TDantlrParser.SCOL]:
                    pass
                else:
                    pass
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 779
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_UPD or _la==TDantlrParser.K_UPDATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 782
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
                if la_ == 1:
                    self.state = 780
                    self.correlation_name()

                elif la_ == 2:
                    self.state = 781
                    self.table_name()


                self.state = 784
                self.from_clause()
                self.state = 785
                self.match(TDantlrParser.K_SET)
                self.state = 786
                self.update_set()
                self.state = 789
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [TDantlrParser.K_WHERE]:
                    self.state = 787
                    self.where_clause()
                    pass
                elif token in [TDantlrParser.K_ALL]:
                    self.state = 788
                    self.match(TDantlrParser.K_ALL)
                    pass
                elif token in [TDantlrParser.EOF, TDantlrParser.SCOL]:
                    pass
                else:
                    pass
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 791
                _la = self._input.LA(1)
                if not(_la==TDantlrParser.K_UPD or _la==TDantlrParser.K_UPDATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 792
                self.table_name()
                self.state = 793
                self.match(TDantlrParser.K_SET)
                self.state = 794
                self.update_set()
                self.state = 795
                self.where_clause()
                self.state = 796
                self.match(TDantlrParser.K_ELSE)
                self.state = 797
                self.insert_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_setContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr_list(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_listContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_update_set

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdate_set" ):
                listener.enterUpdate_set(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdate_set" ):
                listener.exitUpdate_set(self)




    def update_set(self):

        localctx = TDantlrParser.Update_setContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_update_set)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 801
            self.expr_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Merge_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_MERGE(self):
            return self.getToken(TDantlrParser.K_MERGE, 0)

        def merge_target(self):
            return self.getTypedRuleContext(TDantlrParser.Merge_targetContext,0)


        def K_USING(self):
            return self.getToken(TDantlrParser.K_USING, 0)

        def merge_source(self):
            return self.getTypedRuleContext(TDantlrParser.Merge_sourceContext,0)


        def K_ON(self):
            return self.getToken(TDantlrParser.K_ON, 0)

        def merge_condition(self):
            return self.getTypedRuleContext(TDantlrParser.Merge_conditionContext,0)


        def K_INTO(self):
            return self.getToken(TDantlrParser.K_INTO, 0)

        def merge_update(self):
            return self.getTypedRuleContext(TDantlrParser.Merge_updateContext,0)


        def merge_insert(self):
            return self.getTypedRuleContext(TDantlrParser.Merge_insertContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_merge_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMerge_statement" ):
                listener.enterMerge_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMerge_statement" ):
                listener.exitMerge_statement(self)




    def merge_statement(self):

        localctx = TDantlrParser.Merge_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_merge_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 803
            self.match(TDantlrParser.K_MERGE)
            self.state = 805
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_INTO:
                self.state = 804
                self.match(TDantlrParser.K_INTO)


            self.state = 807
            self.merge_target()
            self.state = 808
            self.match(TDantlrParser.K_USING)
            self.state = 809
            self.merge_source()
            self.state = 810
            self.match(TDantlrParser.K_ON)
            self.state = 811
            self.merge_condition()
            self.state = 813
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.state = 812
                self.merge_update()


            self.state = 816
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_WHEN:
                self.state = 815
                self.merge_insert()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Merge_targetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def K_AS(self):
            return self.getToken(TDantlrParser.K_AS, 0)

        def correlation_name(self):
            return self.getTypedRuleContext(TDantlrParser.Correlation_nameContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_merge_target

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMerge_target" ):
                listener.enterMerge_target(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMerge_target" ):
                listener.exitMerge_target(self)




    def merge_target(self):

        localctx = TDantlrParser.Merge_targetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_merge_target)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 818
            self.table_name()
            self.state = 820
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_AS:
                self.state = 819
                self.match(TDantlrParser.K_AS)


            self.state = 823
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.IDENTIFIER:
                self.state = 822
                self.correlation_name()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Merge_sourceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def from_derived_expr(self):
            return self.getTypedRuleContext(TDantlrParser.From_derived_exprContext,0)


        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def K_AS(self):
            return self.getToken(TDantlrParser.K_AS, 0)

        def correlation_name(self):
            return self.getTypedRuleContext(TDantlrParser.Correlation_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)

        def column_list(self):
            return self.getTypedRuleContext(TDantlrParser.Column_listContext,0)


        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_merge_source

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMerge_source" ):
                listener.enterMerge_source(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMerge_source" ):
                listener.exitMerge_source(self)




    def merge_source(self):

        localctx = TDantlrParser.Merge_sourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_merge_source)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 836
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.OPEN_PAR]:
                self.state = 825
                self.from_derived_expr()
                pass
            elif token in [TDantlrParser.IDENTIFIER]:
                self.state = 826
                self.table_name()
                self.state = 828
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.OPEN_PAR:
                    self.state = 827
                    self.match(TDantlrParser.OPEN_PAR)


                self.state = 831
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                if la_ == 1:
                    self.state = 830
                    self.column_list()


                self.state = 834
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.CLOSE_PAR:
                    self.state = 833
                    self.match(TDantlrParser.CLOSE_PAR)


                pass
            else:
                raise NoViableAltException(self)

            self.state = 839
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_AS:
                self.state = 838
                self.match(TDantlrParser.K_AS)


            self.state = 842
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.IDENTIFIER:
                self.state = 841
                self.correlation_name()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Merge_conditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr_list(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_listContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_merge_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMerge_condition" ):
                listener.enterMerge_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMerge_condition" ):
                listener.exitMerge_condition(self)




    def merge_condition(self):

        localctx = TDantlrParser.Merge_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_merge_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 844
            self.expr_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Merge_updateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WHEN(self):
            return self.getToken(TDantlrParser.K_WHEN, 0)

        def K_MATCHED(self):
            return self.getToken(TDantlrParser.K_MATCHED, 0)

        def K_THEN(self):
            return self.getToken(TDantlrParser.K_THEN, 0)

        def K_SET(self):
            return self.getToken(TDantlrParser.K_SET, 0)

        def expr_list(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_listContext,0)


        def K_UPDATE(self):
            return self.getToken(TDantlrParser.K_UPDATE, 0)

        def K_UPD(self):
            return self.getToken(TDantlrParser.K_UPD, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_merge_update

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMerge_update" ):
                listener.enterMerge_update(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMerge_update" ):
                listener.exitMerge_update(self)




    def merge_update(self):

        localctx = TDantlrParser.Merge_updateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_merge_update)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 846
            self.match(TDantlrParser.K_WHEN)
            self.state = 847
            self.match(TDantlrParser.K_MATCHED)
            self.state = 848
            self.match(TDantlrParser.K_THEN)
            self.state = 849
            _la = self._input.LA(1)
            if not(_la==TDantlrParser.K_UPD or _la==TDantlrParser.K_UPDATE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 850
            self.match(TDantlrParser.K_SET)
            self.state = 851
            self.expr_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Merge_insertContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WHEN(self):
            return self.getToken(TDantlrParser.K_WHEN, 0)

        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)

        def K_MATCHED(self):
            return self.getToken(TDantlrParser.K_MATCHED, 0)

        def K_THEN(self):
            return self.getToken(TDantlrParser.K_THEN, 0)

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.OPEN_PAR)
            else:
                return self.getToken(TDantlrParser.OPEN_PAR, i)

        def expr_list(self):
            return self.getTypedRuleContext(TDantlrParser.Expr_listContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.CLOSE_PAR)
            else:
                return self.getToken(TDantlrParser.CLOSE_PAR, i)

        def K_INSERT(self):
            return self.getToken(TDantlrParser.K_INSERT, 0)

        def K_INS(self):
            return self.getToken(TDantlrParser.K_INS, 0)

        def column_list(self):
            return self.getTypedRuleContext(TDantlrParser.Column_listContext,0)


        def K_VALUES(self):
            return self.getToken(TDantlrParser.K_VALUES, 0)

        def insert_logging_errors(self):
            return self.getTypedRuleContext(TDantlrParser.Insert_logging_errorsContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_merge_insert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMerge_insert" ):
                listener.enterMerge_insert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMerge_insert" ):
                listener.exitMerge_insert(self)




    def merge_insert(self):

        localctx = TDantlrParser.Merge_insertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_merge_insert)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 853
            self.match(TDantlrParser.K_WHEN)
            self.state = 854
            self.match(TDantlrParser.K_NOT)
            self.state = 855
            self.match(TDantlrParser.K_MATCHED)
            self.state = 856
            self.match(TDantlrParser.K_THEN)
            self.state = 857
            _la = self._input.LA(1)
            if not(_la==TDantlrParser.K_INS or _la==TDantlrParser.K_INSERT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 859
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,125,self._ctx)
            if la_ == 1:
                self.state = 858
                self.match(TDantlrParser.OPEN_PAR)


            self.state = 862
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.IDENTIFIER:
                self.state = 861
                self.column_list()


            self.state = 865
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.CLOSE_PAR:
                self.state = 864
                self.match(TDantlrParser.CLOSE_PAR)


            self.state = 868
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_VALUES:
                self.state = 867
                self.match(TDantlrParser.K_VALUES)


            self.state = 870
            self.match(TDantlrParser.OPEN_PAR)
            self.state = 871
            self.expr_list()
            self.state = 872
            self.match(TDantlrParser.CLOSE_PAR)
            self.state = 874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_LOGGING:
                self.state = 873
                self.insert_logging_errors()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_positionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(TDantlrParser.INTEGER, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_column_position

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_position" ):
                listener.enterColumn_position(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_position" ):
                listener.exitColumn_position(self)




    def column_position(self):

        localctx = TDantlrParser.Column_positionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_column_position)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 876
            self.match(TDantlrParser.INTEGER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Search_conditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)


        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.OPEN_PAR)
            else:
                return self.getToken(TDantlrParser.OPEN_PAR, i)

        def subquery(self):
            return self.getTypedRuleContext(TDantlrParser.SubqueryContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.CLOSE_PAR)
            else:
                return self.getToken(TDantlrParser.CLOSE_PAR, i)

        def LT(self):
            return self.getToken(TDantlrParser.LT, 0)

        def LT_EQ(self):
            return self.getToken(TDantlrParser.LT_EQ, 0)

        def GT(self):
            return self.getToken(TDantlrParser.GT, 0)

        def GT_EQ(self):
            return self.getToken(TDantlrParser.GT_EQ, 0)

        def ASSIGN(self):
            return self.getToken(TDantlrParser.ASSIGN, 0)

        def NOT_EQ2(self):
            return self.getToken(TDantlrParser.NOT_EQ2, 0)

        def K_IN(self):
            return self.getToken(TDantlrParser.K_IN, 0)

        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)

        def column_list(self):
            return self.getTypedRuleContext(TDantlrParser.Column_listContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_search_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSearch_condition" ):
                listener.enterSearch_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSearch_condition" ):
                listener.exitSearch_condition(self)




    def search_condition(self):

        localctx = TDantlrParser.Search_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_search_condition)
        try:
            self.state = 907
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 878
                self.expr(0)
                self.state = 888
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [TDantlrParser.LT]:
                    self.state = 879
                    self.match(TDantlrParser.LT)
                    pass
                elif token in [TDantlrParser.LT_EQ]:
                    self.state = 880
                    self.match(TDantlrParser.LT_EQ)
                    pass
                elif token in [TDantlrParser.GT]:
                    self.state = 881
                    self.match(TDantlrParser.GT)
                    pass
                elif token in [TDantlrParser.GT_EQ]:
                    self.state = 882
                    self.match(TDantlrParser.GT_EQ)
                    pass
                elif token in [TDantlrParser.ASSIGN]:
                    self.state = 883
                    self.match(TDantlrParser.ASSIGN)
                    pass
                elif token in [TDantlrParser.NOT_EQ2]:
                    self.state = 884
                    self.match(TDantlrParser.NOT_EQ2)
                    pass
                elif token in [TDantlrParser.K_IN]:
                    self.state = 885
                    self.match(TDantlrParser.K_IN)
                    pass
                elif token in [TDantlrParser.K_NOT]:
                    self.state = 886
                    self.match(TDantlrParser.K_NOT)
                    self.state = 887
                    self.match(TDantlrParser.K_IN)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 890
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 891
                self.subquery()
                self.state = 892
                self.match(TDantlrParser.CLOSE_PAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 894
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 895
                self.column_list()
                self.state = 896
                self.match(TDantlrParser.CLOSE_PAR)
                self.state = 900
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [TDantlrParser.K_IN]:
                    self.state = 897
                    self.match(TDantlrParser.K_IN)
                    pass
                elif token in [TDantlrParser.K_NOT]:
                    self.state = 898
                    self.match(TDantlrParser.K_NOT)
                    self.state = 899
                    self.match(TDantlrParser.K_IN)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 902
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 903
                self.subquery()
                self.state = 904
                self.match(TDantlrParser.CLOSE_PAR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 906
                self.expr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conditional_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(TDantlrParser.ExprContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_conditional_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional_expr" ):
                listener.enterConditional_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional_expr" ):
                listener.exitConditional_expr(self)




    def conditional_expr(self):

        localctx = TDantlrParser.Conditional_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_conditional_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 909
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TDantlrParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(TDantlrParser.Column_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_column_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_list" ):
                listener.enterColumn_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_list" ):
                listener.exitColumn_list(self)




    def column_list(self):

        localctx = TDantlrParser.Column_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_column_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 911
            self.column_name()
            self.state = 916
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,133,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 912
                    self.match(TDantlrParser.COMMA)
                    self.state = 913
                    self.column_name() 
                self.state = 918
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,133,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Literal_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC_LITERAL(self):
            return self.getToken(TDantlrParser.NUMERIC_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(TDantlrParser.STRING_LITERAL, 0)

        def K_NULL(self):
            return self.getToken(TDantlrParser.K_NULL, 0)

        def date_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Date_exprContext,0)


        def time_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Time_exprContext,0)


        def timestamp_expr(self):
            return self.getTypedRuleContext(TDantlrParser.Timestamp_exprContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_literal_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral_value" ):
                listener.enterLiteral_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral_value" ):
                listener.exitLiteral_value(self)




    def literal_value(self):

        localctx = TDantlrParser.Literal_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_literal_value)
        try:
            self.state = 925
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 919
                self.match(TDantlrParser.NUMERIC_LITERAL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 920
                self.match(TDantlrParser.STRING_LITERAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 921
                self.match(TDantlrParser.K_NULL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 922
                self.date_expr()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 923
                self.time_expr()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 924
                self.timestamp_expr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(TDantlrParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(TDantlrParser.PLUS, 0)

        def TILDE(self):
            return self.getToken(TDantlrParser.TILDE, 0)

        def K_NOT(self):
            return self.getToken(TDantlrParser.K_NOT, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_unary_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)




    def unary_operator(self):

        localctx = TDantlrParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 927
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TDantlrParser.PLUS) | (1 << TDantlrParser.MINUS) | (1 << TDantlrParser.TILDE))) != 0) or _la==TDantlrParser.K_NOT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_operationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_UNION(self):
            return self.getToken(TDantlrParser.K_UNION, 0)

        def K_ALL(self):
            return self.getToken(TDantlrParser.K_ALL, 0)

        def K_INTERSECT(self):
            return self.getToken(TDantlrParser.K_INTERSECT, 0)

        def K_MINUS(self):
            return self.getToken(TDantlrParser.K_MINUS, 0)

        def K_EXCEPT(self):
            return self.getToken(TDantlrParser.K_EXCEPT, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_set_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_operation" ):
                listener.enterSet_operation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_operation" ):
                listener.exitSet_operation(self)




    def set_operation(self):

        localctx = TDantlrParser.Set_operationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_set_operation)
        self._la = 0 # Token type
        try:
            self.state = 945
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TDantlrParser.K_UNION]:
                self.enterOuterAlt(localctx, 1)
                self.state = 929
                self.match(TDantlrParser.K_UNION)
                self.state = 931
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_ALL:
                    self.state = 930
                    self.match(TDantlrParser.K_ALL)


                pass
            elif token in [TDantlrParser.K_INTERSECT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 933
                self.match(TDantlrParser.K_INTERSECT)
                self.state = 935
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_ALL:
                    self.state = 934
                    self.match(TDantlrParser.K_ALL)


                pass
            elif token in [TDantlrParser.K_MINUS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 937
                self.match(TDantlrParser.K_MINUS)
                self.state = 939
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_ALL:
                    self.state = 938
                    self.match(TDantlrParser.K_ALL)


                pass
            elif token in [TDantlrParser.K_EXCEPT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 941
                self.match(TDantlrParser.K_EXCEPT)
                self.state = 943
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==TDantlrParser.K_ALL:
                    self.state = 942
                    self.match(TDantlrParser.K_ALL)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_aliasContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TDantlrParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_column_alias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_alias" ):
                listener.enterColumn_alias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_alias" ):
                listener.exitColumn_alias(self)




    def column_alias(self):

        localctx = TDantlrParser.Column_aliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_column_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947
            self.match(TDantlrParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Query_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TDantlrParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_query_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery_name" ):
                listener.enterQuery_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery_name" ):
                listener.exitQuery_name(self)




    def query_name(self):

        localctx = TDantlrParser.Query_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_query_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 949
            self.match(TDantlrParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expr_alias_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TDantlrParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_expr_alias_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_alias_name" ):
                listener.enterExpr_alias_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_alias_name" ):
                listener.exitExpr_alias_name(self)




    def expr_alias_name(self):

        localctx = TDantlrParser.Expr_alias_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_expr_alias_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 951
            self.match(TDantlrParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Derived_table_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_derived_table_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerived_table_name" ):
                listener.enterDerived_table_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerived_table_name" ):
                listener.exitDerived_table_name(self)




    def derived_table_name(self):

        localctx = TDantlrParser.Derived_table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_derived_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 953
            self.table_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(TDantlrParser.STRING_LITERAL, 0)

        def K_DATE(self):
            return self.getToken(TDantlrParser.K_DATE, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_date_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_expr" ):
                listener.enterDate_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_expr" ):
                listener.exitDate_expr(self)




    def date_expr(self):

        localctx = TDantlrParser.Date_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_date_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 956
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_DATE:
                self.state = 955
                self.match(TDantlrParser.K_DATE)


            self.state = 958
            self.match(TDantlrParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Timestamp_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(TDantlrParser.STRING_LITERAL, 0)

        def K_TIMESTAMP(self):
            return self.getToken(TDantlrParser.K_TIMESTAMP, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_timestamp_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimestamp_expr" ):
                listener.enterTimestamp_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimestamp_expr" ):
                listener.exitTimestamp_expr(self)




    def timestamp_expr(self):

        localctx = TDantlrParser.Timestamp_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_timestamp_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 961
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_TIMESTAMP:
                self.state = 960
                self.match(TDantlrParser.K_TIMESTAMP)


            self.state = 963
            self.match(TDantlrParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(TDantlrParser.STRING_LITERAL, 0)

        def K_TIME(self):
            return self.getToken(TDantlrParser.K_TIME, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_time_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_expr" ):
                listener.enterTime_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_expr" ):
                listener.exitTime_expr(self)




    def time_expr(self):

        localctx = TDantlrParser.Time_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_time_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 966
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==TDantlrParser.K_TIME:
                self.state = 965
                self.match(TDantlrParser.K_TIME)


            self.state = 968
            self.match(TDantlrParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Database_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TDantlrParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_database_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabase_name" ):
                listener.enterDatabase_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabase_name" ):
                listener.exitDatabase_name(self)




    def database_name(self):

        localctx = TDantlrParser.Database_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_database_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 970
            self.match(TDantlrParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TDantlrParser.IDENTIFIER, 0)

        def database_name(self):
            return self.getTypedRuleContext(TDantlrParser.Database_nameContext,0)


        def DOT(self):
            return self.getToken(TDantlrParser.DOT, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_table_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_name" ):
                listener.enterTable_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_name" ):
                listener.exitTable_name(self)




    def table_name(self):

        localctx = TDantlrParser.Table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 975
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,143,self._ctx)
            if la_ == 1:
                self.state = 972
                self.database_name()
                self.state = 973
                self.match(TDantlrParser.DOT)


            self.state = 977
            self.match(TDantlrParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TDantlrParser.IDENTIFIER, 0)

        def correlation_name(self):
            return self.getTypedRuleContext(TDantlrParser.Correlation_nameContext,0)


        def DOT(self):
            return self.getToken(TDantlrParser.DOT, 0)

        def table_name(self):
            return self.getTypedRuleContext(TDantlrParser.Table_nameContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_column_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_name" ):
                listener.enterColumn_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_name" ):
                listener.exitColumn_name(self)




    def column_name(self):

        localctx = TDantlrParser.Column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_column_name)
        try:
            self.state = 991
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 982
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,144,self._ctx)
                if la_ == 1:
                    self.state = 979
                    self.correlation_name()
                    self.state = 980
                    self.match(TDantlrParser.DOT)


                self.state = 984
                self.match(TDantlrParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 988
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
                if la_ == 1:
                    self.state = 985
                    self.table_name()
                    self.state = 986
                    self.match(TDantlrParser.DOT)


                self.state = 990
                self.match(TDantlrParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Correlation_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TDantlrParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_correlation_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCorrelation_name" ):
                listener.enterCorrelation_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCorrelation_name" ):
                listener.exitCorrelation_name(self)




    def correlation_name(self):

        localctx = TDantlrParser.Correlation_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_correlation_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 993
            self.match(TDantlrParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def types(self):
            return self.getTypedRuleContext(TDantlrParser.TypesContext,0)


        def OPEN_PAR(self):
            return self.getToken(TDantlrParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(TDantlrParser.CLOSE_PAR, 0)

        def STRING_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.STRING_LITERAL)
            else:
                return self.getToken(TDantlrParser.STRING_LITERAL, i)

        def NUMERIC_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.NUMERIC_LITERAL)
            else:
                return self.getToken(TDantlrParser.NUMERIC_LITERAL, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(TDantlrParser.COMMA)
            else:
                return self.getToken(TDantlrParser.COMMA, i)

        def getRuleIndex(self):
            return TDantlrParser.RULE_type_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_name" ):
                listener.enterType_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_name" ):
                listener.exitType_name(self)




    def type_name(self):

        localctx = TDantlrParser.Type_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_type_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 995
            self.types()
            self.state = 1003
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
            if la_ == 1:
                self.state = 996
                self.match(TDantlrParser.OPEN_PAR)
                self.state = 998 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 997
                    _la = self._input.LA(1)
                    if not(_la==TDantlrParser.COMMA or _la==TDantlrParser.NUMERIC_LITERAL or _la==TDantlrParser.STRING_LITERAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1000 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==TDantlrParser.COMMA or _la==TDantlrParser.NUMERIC_LITERAL or _la==TDantlrParser.STRING_LITERAL):
                        break

                self.state = 1002
                self.match(TDantlrParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DATE(self):
            return self.getToken(TDantlrParser.K_DATE, 0)

        def K_TIME(self):
            return self.getToken(TDantlrParser.K_TIME, 0)

        def K_TIMESTAMP(self):
            return self.getToken(TDantlrParser.K_TIMESTAMP, 0)

        def K_INTEGER(self):
            return self.getToken(TDantlrParser.K_INTEGER, 0)

        def K_DEC(self):
            return self.getToken(TDantlrParser.K_DEC, 0)

        def K_DECIMAL(self):
            return self.getToken(TDantlrParser.K_DECIMAL, 0)

        def K_CHAR(self):
            return self.getToken(TDantlrParser.K_CHAR, 0)

        def K_CHARACTER(self):
            return self.getToken(TDantlrParser.K_CHARACTER, 0)

        def K_VARCHAR(self):
            return self.getToken(TDantlrParser.K_VARCHAR, 0)

        def K_FLOAT(self):
            return self.getToken(TDantlrParser.K_FLOAT, 0)

        def K_INT(self):
            return self.getToken(TDantlrParser.K_INT, 0)

        def K_SMALLINT(self):
            return self.getToken(TDantlrParser.K_SMALLINT, 0)

        def K_BIGINT(self):
            return self.getToken(TDantlrParser.K_BIGINT, 0)

        def K_BLOB(self):
            return self.getToken(TDantlrParser.K_BLOB, 0)

        def K_VARBYTE(self):
            return self.getToken(TDantlrParser.K_VARBYTE, 0)

        def K_BYTE(self):
            return self.getToken(TDantlrParser.K_BYTE, 0)

        def K_BYTEINT(self):
            return self.getToken(TDantlrParser.K_BYTEINT, 0)

        def K_NUMERIC(self):
            return self.getToken(TDantlrParser.K_NUMERIC, 0)

        def K_DOUBLE(self):
            return self.getToken(TDantlrParser.K_DOUBLE, 0)

        def K_CURSOR(self):
            return self.getToken(TDantlrParser.K_CURSOR, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_types

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypes" ):
                listener.enterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypes" ):
                listener.exitTypes(self)




    def types(self):

        localctx = TDantlrParser.TypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_types)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1005
            _la = self._input.LA(1)
            if not(((((_la - 122)) & ~0x3f) == 0 and ((1 << (_la - 122)) & ((1 << (TDantlrParser.K_CURSOR - 122)) | (1 << (TDantlrParser.K_TIME - 122)) | (1 << (TDantlrParser.K_DATE - 122)) | (1 << (TDantlrParser.K_TIMESTAMP - 122)) | (1 << (TDantlrParser.K_DEC - 122)) | (1 << (TDantlrParser.K_DECIMAL - 122)))) != 0) or ((((_la - 235)) & ~0x3f) == 0 and ((1 << (_la - 235)) & ((1 << (TDantlrParser.K_BLOB - 235)) | (1 << (TDantlrParser.K_NUMERIC - 235)) | (1 << (TDantlrParser.K_INT - 235)) | (1 << (TDantlrParser.K_DOUBLE - 235)) | (1 << (TDantlrParser.K_INTEGER - 235)) | (1 << (TDantlrParser.K_BYTE - 235)) | (1 << (TDantlrParser.K_BYTEINT - 235)))) != 0) or ((((_la - 318)) & ~0x3f) == 0 and ((1 << (_la - 318)) & ((1 << (TDantlrParser.K_VARBYTE - 318)) | (1 << (TDantlrParser.K_CHAR - 318)) | (1 << (TDantlrParser.K_VARCHAR - 318)) | (1 << (TDantlrParser.K_CHARACTER - 318)) | (1 << (TDantlrParser.K_SMALLINT - 318)))) != 0) or _la==TDantlrParser.K_FLOAT or _la==TDantlrParser.K_BIGINT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def td_function_name(self):
            return self.getTypedRuleContext(TDantlrParser.Td_function_nameContext,0)


        def analytical_function_name(self):
            return self.getTypedRuleContext(TDantlrParser.Analytical_function_nameContext,0)


        def custom_function_name(self):
            return self.getTypedRuleContext(TDantlrParser.Custom_function_nameContext,0)


        def getRuleIndex(self):
            return TDantlrParser.RULE_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_name" ):
                listener.enterFunction_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_name" ):
                listener.exitFunction_name(self)




    def function_name(self):

        localctx = TDantlrParser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_function_name)
        try:
            self.state = 1010
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1007
                self.td_function_name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1008
                self.analytical_function_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1009
                self.custom_function_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Td_function_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SUBSTR(self):
            return self.getToken(TDantlrParser.K_SUBSTR, 0)

        def K_UPPER(self):
            return self.getToken(TDantlrParser.K_UPPER, 0)

        def K_LOWER(self):
            return self.getToken(TDantlrParser.K_LOWER, 0)

        def K_TRIM(self):
            return self.getToken(TDantlrParser.K_TRIM, 0)

        def K_LTRIM(self):
            return self.getToken(TDantlrParser.K_LTRIM, 0)

        def K_RTRIM(self):
            return self.getToken(TDantlrParser.K_RTRIM, 0)

        def K_CURRENT_TIMESTAMP(self):
            return self.getToken(TDantlrParser.K_CURRENT_TIMESTAMP, 0)

        def K_COVAR_POP(self):
            return self.getToken(TDantlrParser.K_COVAR_POP, 0)

        def K_COVAR_SAMP(self):
            return self.getToken(TDantlrParser.K_COVAR_SAMP, 0)

        def K_KURTOSIS(self):
            return self.getToken(TDantlrParser.K_KURTOSIS, 0)

        def K_REGR_AVGX(self):
            return self.getToken(TDantlrParser.K_REGR_AVGX, 0)

        def K_REGR_AVGY(self):
            return self.getToken(TDantlrParser.K_REGR_AVGY, 0)

        def K_REGR_COUNT(self):
            return self.getToken(TDantlrParser.K_REGR_COUNT, 0)

        def K_VARGRAPHIC(self):
            return self.getToken(TDantlrParser.K_VARGRAPHIC, 0)

        def K_REGR_INTERCEPT(self):
            return self.getToken(TDantlrParser.K_REGR_INTERCEPT, 0)

        def K_REGR_R2(self):
            return self.getToken(TDantlrParser.K_REGR_R2, 0)

        def K_REGR_SLOPE(self):
            return self.getToken(TDantlrParser.K_REGR_SLOPE, 0)

        def K_REGR_SXX(self):
            return self.getToken(TDantlrParser.K_REGR_SXX, 0)

        def K_REGR_SXY(self):
            return self.getToken(TDantlrParser.K_REGR_SXY, 0)

        def K_REGR_SYY(self):
            return self.getToken(TDantlrParser.K_REGR_SYY, 0)

        def K_SKEW(self):
            return self.getToken(TDantlrParser.K_SKEW, 0)

        def K_STDDEV_POP(self):
            return self.getToken(TDantlrParser.K_STDDEV_POP, 0)

        def K_STDDEV_SAMP(self):
            return self.getToken(TDantlrParser.K_STDDEV_SAMP, 0)

        def K_VAR_POP(self):
            return self.getToken(TDantlrParser.K_VAR_POP, 0)

        def K_ABS(self):
            return self.getToken(TDantlrParser.K_ABS, 0)

        def K_CASE_N(self):
            return self.getToken(TDantlrParser.K_CASE_N, 0)

        def K_CEILING(self):
            return self.getToken(TDantlrParser.K_CEILING, 0)

        def K_EXP(self):
            return self.getToken(TDantlrParser.K_EXP, 0)

        def K_FLOOR(self):
            return self.getToken(TDantlrParser.K_FLOOR, 0)

        def K_LN(self):
            return self.getToken(TDantlrParser.K_LN, 0)

        def K_LOG(self):
            return self.getToken(TDantlrParser.K_LOG, 0)

        def K_NULLIFZERO(self):
            return self.getToken(TDantlrParser.K_NULLIFZERO, 0)

        def K_NVL(self):
            return self.getToken(TDantlrParser.K_NVL, 0)

        def K_POWER(self):
            return self.getToken(TDantlrParser.K_POWER, 0)

        def K_RANDOM(self):
            return self.getToken(TDantlrParser.K_RANDOM, 0)

        def K_RANGE_N(self):
            return self.getToken(TDantlrParser.K_RANGE_N, 0)

        def K_ROUND(self):
            return self.getToken(TDantlrParser.K_ROUND, 0)

        def K_SIGN(self):
            return self.getToken(TDantlrParser.K_SIGN, 0)

        def K_SQRT(self):
            return self.getToken(TDantlrParser.K_SQRT, 0)

        def K_TRUNC(self):
            return self.getToken(TDantlrParser.K_TRUNC, 0)

        def K_WIDTH_BUCKET(self):
            return self.getToken(TDantlrParser.K_WIDTH_BUCKET, 0)

        def K_ZEROIFNULL(self):
            return self.getToken(TDantlrParser.K_ZEROIFNULL, 0)

        def K_COS(self):
            return self.getToken(TDantlrParser.K_COS, 0)

        def K_SIN(self):
            return self.getToken(TDantlrParser.K_SIN, 0)

        def K_TAN(self):
            return self.getToken(TDantlrParser.K_TAN, 0)

        def K_ACOS(self):
            return self.getToken(TDantlrParser.K_ACOS, 0)

        def K_ASIN(self):
            return self.getToken(TDantlrParser.K_ASIN, 0)

        def K_ATAN(self):
            return self.getToken(TDantlrParser.K_ATAN, 0)

        def K_ATAN2(self):
            return self.getToken(TDantlrParser.K_ATAN2, 0)

        def K_DEGREESRADIANS(self):
            return self.getToken(TDantlrParser.K_DEGREESRADIANS, 0)

        def K_COSH(self):
            return self.getToken(TDantlrParser.K_COSH, 0)

        def K_SINH(self):
            return self.getToken(TDantlrParser.K_SINH, 0)

        def K_TANH(self):
            return self.getToken(TDantlrParser.K_TANH, 0)

        def K_ACOSH(self):
            return self.getToken(TDantlrParser.K_ACOSH, 0)

        def K_ASINH(self):
            return self.getToken(TDantlrParser.K_ASINH, 0)

        def K_ATANH(self):
            return self.getToken(TDantlrParser.K_ATANH, 0)

        def K_ASCII(self):
            return self.getToken(TDantlrParser.K_ASCII, 0)

        def K_CHAR2HEXINT(self):
            return self.getToken(TDantlrParser.K_CHAR2HEXINT, 0)

        def K_CHR(self):
            return self.getToken(TDantlrParser.K_CHR, 0)

        def K_CSV(self):
            return self.getToken(TDantlrParser.K_CSV, 0)

        def K_CSVLD(self):
            return self.getToken(TDantlrParser.K_CSVLD, 0)

        def K_EDITDISTANCE(self):
            return self.getToken(TDantlrParser.K_EDITDISTANCE, 0)

        def K_INDEX(self):
            return self.getToken(TDantlrParser.K_INDEX, 0)

        def K_INITCAP(self):
            return self.getToken(TDantlrParser.K_INITCAP, 0)

        def K_INSTR(self):
            return self.getToken(TDantlrParser.K_INSTR, 0)

        def K_LENGTH(self):
            return self.getToken(TDantlrParser.K_LENGTH, 0)

        def K_LPAD(self):
            return self.getToken(TDantlrParser.K_LPAD, 0)

        def K_NGRAM(self):
            return self.getToken(TDantlrParser.K_NGRAM, 0)

        def K_NVP(self):
            return self.getToken(TDantlrParser.K_NVP, 0)

        def K_OREPLACE(self):
            return self.getToken(TDantlrParser.K_OREPLACE, 0)

        def K_OTRANSLATE(self):
            return self.getToken(TDantlrParser.K_OTRANSLATE, 0)

        def K_POSITION(self):
            return self.getToken(TDantlrParser.K_POSITION, 0)

        def K_RPAD(self):
            return self.getToken(TDantlrParser.K_RPAD, 0)

        def K_SOUNDEX(self):
            return self.getToken(TDantlrParser.K_SOUNDEX, 0)

        def K_STRING_CS(self):
            return self.getToken(TDantlrParser.K_STRING_CS, 0)

        def K_STRTOK(self):
            return self.getToken(TDantlrParser.K_STRTOK, 0)

        def K_STRTOK_SPLIT_TO_TABLE(self):
            return self.getToken(TDantlrParser.K_STRTOK_SPLIT_TO_TABLE, 0)

        def K_SUBSTRING(self):
            return self.getToken(TDantlrParser.K_SUBSTRING, 0)

        def K_NVL2(self):
            return self.getToken(TDantlrParser.K_NVL2, 0)

        def K_TRANSLATE(self):
            return self.getToken(TDantlrParser.K_TRANSLATE, 0)

        def K_TRANSLATE_CHK(self):
            return self.getToken(TDantlrParser.K_TRANSLATE_CHK, 0)

        def K_EXTRACT(self):
            return self.getToken(TDantlrParser.K_EXTRACT, 0)

        def K_COALESCE(self):
            return self.getToken(TDantlrParser.K_COALESCE, 0)

        def K_USER(self):
            return self.getToken(TDantlrParser.K_USER, 0)

        def K_ACCOUNT(self):
            return self.getToken(TDantlrParser.K_ACCOUNT, 0)

        def K_CURRENT_DATE(self):
            return self.getToken(TDantlrParser.K_CURRENT_DATE, 0)

        def K_CURRENT_ROLE(self):
            return self.getToken(TDantlrParser.K_CURRENT_ROLE, 0)

        def K_CURRENT_TIME(self):
            return self.getToken(TDantlrParser.K_CURRENT_TIME, 0)

        def K_CURRENT_USER(self):
            return self.getToken(TDantlrParser.K_CURRENT_USER, 0)

        def K_DATABASE(self):
            return self.getToken(TDantlrParser.K_DATABASE, 0)

        def K_DATE(self):
            return self.getToken(TDantlrParser.K_DATE, 0)

        def K_PROFILE(self):
            return self.getToken(TDantlrParser.K_PROFILE, 0)

        def K_ROLE(self):
            return self.getToken(TDantlrParser.K_ROLE, 0)

        def K_SESSION(self):
            return self.getToken(TDantlrParser.K_SESSION, 0)

        def K_TEMPORAL_DATE(self):
            return self.getToken(TDantlrParser.K_TEMPORAL_DATE, 0)

        def K_TEMPORAL_TIMESTAMP(self):
            return self.getToken(TDantlrParser.K_TEMPORAL_TIMESTAMP, 0)

        def K_TIME(self):
            return self.getToken(TDantlrParser.K_TIME, 0)

        def K_BITAND(self):
            return self.getToken(TDantlrParser.K_BITAND, 0)

        def K_BITNOT(self):
            return self.getToken(TDantlrParser.K_BITNOT, 0)

        def K_BITOR(self):
            return self.getToken(TDantlrParser.K_BITOR, 0)

        def K_BITXOR(self):
            return self.getToken(TDantlrParser.K_BITXOR, 0)

        def K_COUNTSET(self):
            return self.getToken(TDantlrParser.K_COUNTSET, 0)

        def K_GETBIT(self):
            return self.getToken(TDantlrParser.K_GETBIT, 0)

        def K_ROTATELEFT(self):
            return self.getToken(TDantlrParser.K_ROTATELEFT, 0)

        def K_ROTATERIGHT(self):
            return self.getToken(TDantlrParser.K_ROTATERIGHT, 0)

        def K_SETBIT(self):
            return self.getToken(TDantlrParser.K_SETBIT, 0)

        def K_SHIFTLEFT(self):
            return self.getToken(TDantlrParser.K_SHIFTLEFT, 0)

        def K_SHIFTRIGHT(self):
            return self.getToken(TDantlrParser.K_SHIFTRIGHT, 0)

        def K_SUBBITSTR(self):
            return self.getToken(TDantlrParser.K_SUBBITSTR, 0)

        def K_TO_BYTE(self):
            return self.getToken(TDantlrParser.K_TO_BYTE, 0)

        def K_BYTE(self):
            return self.getToken(TDantlrParser.K_BYTE, 0)

        def K_BYTES(self):
            return self.getToken(TDantlrParser.K_BYTES, 0)

        def K_CHAR_LENGTH(self):
            return self.getToken(TDantlrParser.K_CHAR_LENGTH, 0)

        def K_CHARACTER_LENGTH(self):
            return self.getToken(TDantlrParser.K_CHARACTER_LENGTH, 0)

        def K_CHAR(self):
            return self.getToken(TDantlrParser.K_CHAR, 0)

        def K_CHARS(self):
            return self.getToken(TDantlrParser.K_CHARS, 0)

        def K_CHARACTERS(self):
            return self.getToken(TDantlrParser.K_CHARACTERS, 0)

        def K_DEFAULT(self):
            return self.getToken(TDantlrParser.K_DEFAULT, 0)

        def K_FORMAT(self):
            return self.getToken(TDantlrParser.K_FORMAT, 0)

        def K_OCTET_LENGTH(self):
            return self.getToken(TDantlrParser.K_OCTET_LENGTH, 0)

        def K_TITLE(self):
            return self.getToken(TDantlrParser.K_TITLE, 0)

        def K_TYPE(self):
            return self.getToken(TDantlrParser.K_TYPE, 0)

        def K_AVG(self):
            return self.getToken(TDantlrParser.K_AVG, 0)

        def K_MIN(self):
            return self.getToken(TDantlrParser.K_MIN, 0)

        def K_MAX(self):
            return self.getToken(TDantlrParser.K_MAX, 0)

        def K_SUM(self):
            return self.getToken(TDantlrParser.K_SUM, 0)

        def K_COUNT(self):
            return self.getToken(TDantlrParser.K_COUNT, 0)

        def K_CORR(self):
            return self.getToken(TDantlrParser.K_CORR, 0)

        def K_ADD_MONTHS(self):
            return self.getToken(TDantlrParser.K_ADD_MONTHS, 0)

        def K_TO_CHAR(self):
            return self.getToken(TDantlrParser.K_TO_CHAR, 0)

        def K_INTERVAL(self):
            return self.getToken(TDantlrParser.K_INTERVAL, 0)

        def K_CAST(self):
            return self.getToken(TDantlrParser.K_CAST, 0)

        def K_TO_DATE(self):
            return self.getToken(TDantlrParser.K_TO_DATE, 0)

        def K_TO_TIMESTAMP(self):
            return self.getToken(TDantlrParser.K_TO_TIMESTAMP, 0)

        def K_TO_NUMBER(self):
            return self.getToken(TDantlrParser.K_TO_NUMBER, 0)

        def K_OADD_MONTHS(self):
            return self.getToken(TDantlrParser.K_OADD_MONTHS, 0)

        def K_GROUPING(self):
            return self.getToken(TDantlrParser.K_GROUPING, 0)

        def K_MAXIMUM(self):
            return self.getToken(TDantlrParser.K_MAXIMUM, 0)

        def K_MINIMUM(self):
            return self.getToken(TDantlrParser.K_MINIMUM, 0)

        def K_VAR_SAMP(self):
            return self.getToken(TDantlrParser.K_VAR_SAMP, 0)

        def K_CEIL(self):
            return self.getToken(TDantlrParser.K_CEIL, 0)

        def K_DEGREES(self):
            return self.getToken(TDantlrParser.K_DEGREES, 0)

        def K_RADIANS(self):
            return self.getToken(TDantlrParser.K_RADIANS, 0)

        def K_MOD(self):
            return self.getToken(TDantlrParser.K_MOD, 0)

        def K_GREATEST(self):
            return self.getToken(TDantlrParser.K_GREATEST, 0)

        def K_LEAST(self):
            return self.getToken(TDantlrParser.K_LEAST, 0)

        def K_LAST_DAY(self):
            return self.getToken(TDantlrParser.K_LAST_DAY, 0)

        def K_NEXT_DAY(self):
            return self.getToken(TDantlrParser.K_NEXT_DAY, 0)

        def K_MONTHS_BETWEEN(self):
            return self.getToken(TDantlrParser.K_MONTHS_BETWEEN, 0)

        def K_CUME_DIST(self):
            return self.getToken(TDantlrParser.K_CUME_DIST, 0)

        def K_DENSE_RANK(self):
            return self.getToken(TDantlrParser.K_DENSE_RANK, 0)

        def K_FIRST_VALUE(self):
            return self.getToken(TDantlrParser.K_FIRST_VALUE, 0)

        def K_LAST_VALUE(self):
            return self.getToken(TDantlrParser.K_LAST_VALUE, 0)

        def K_PERCENT_RANK(self):
            return self.getToken(TDantlrParser.K_PERCENT_RANK, 0)

        def K_RANK(self):
            return self.getToken(TDantlrParser.K_RANK, 0)

        def K_ROW_NUMBER(self):
            return self.getToken(TDantlrParser.K_ROW_NUMBER, 0)

        def K_LEFT(self):
            return self.getToken(TDantlrParser.K_LEFT, 0)

        def K_REVERSE(self):
            return self.getToken(TDantlrParser.K_REVERSE, 0)

        def K_RIGHT(self):
            return self.getToken(TDantlrParser.K_RIGHT, 0)

        def K_NULLIF(self):
            return self.getToken(TDantlrParser.K_NULLIF, 0)

        def K_TD_DAY_OF_WEEK(self):
            return self.getToken(TDantlrParser.K_TD_DAY_OF_WEEK, 0)

        def K_TD_DAY_OF_MONTH(self):
            return self.getToken(TDantlrParser.K_TD_DAY_OF_MONTH, 0)

        def K_TD_DAY_OF_YEAR(self):
            return self.getToken(TDantlrParser.K_TD_DAY_OF_YEAR, 0)

        def K_TD_WEEK_OF_YEAR(self):
            return self.getToken(TDantlrParser.K_TD_WEEK_OF_YEAR, 0)

        def K_TD_MONTH_OF_QUARTER(self):
            return self.getToken(TDantlrParser.K_TD_MONTH_OF_QUARTER, 0)

        def K_TD_MONTH_OF_YEAR(self):
            return self.getToken(TDantlrParser.K_TD_MONTH_OF_YEAR, 0)

        def K_TD_QUARTER_OF_YEAR(self):
            return self.getToken(TDantlrParser.K_TD_QUARTER_OF_YEAR, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_td_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTd_function_name" ):
                listener.enterTd_function_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTd_function_name" ):
                listener.exitTd_function_name(self)




    def td_function_name(self):

        localctx = TDantlrParser.Td_function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_td_function_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1012
            _la = self._input.LA(1)
            if not(((((_la - 28)) & ~0x3f) == 0 and ((1 << (_la - 28)) & ((1 << (TDantlrParser.K_MAX - 28)) | (1 << (TDantlrParser.K_CORR - 28)) | (1 << (TDantlrParser.K_MAXIMUM - 28)) | (1 << (TDantlrParser.K_ABS - 28)) | (1 << (TDantlrParser.K_COS - 28)) | (1 << (TDantlrParser.K_STDDEV_POP - 28)) | (1 << (TDantlrParser.K_COSH - 28)) | (1 << (TDantlrParser.K_RADIANS - 28)) | (1 << (TDantlrParser.K_STDDEV_SAMP - 28)) | (1 << (TDantlrParser.K_ACCOUNT - 28)) | (1 << (TDantlrParser.K_COUNT - 28)) | (1 << (TDantlrParser.K_RANDOM - 28)) | (1 << (TDantlrParser.K_ACOS - 28)) | (1 << (TDantlrParser.K_COVAR_POP - 28)) | (1 << (TDantlrParser.K_MIN - 28)) | (1 << (TDantlrParser.K_RANGE_N - 28)) | (1 << (TDantlrParser.K_STRING_CS - 28)) | (1 << (TDantlrParser.K_ACOSH - 28)) | (1 << (TDantlrParser.K_COVAR_SAMP - 28)) | (1 << (TDantlrParser.K_RANK - 28)) | (1 << (TDantlrParser.K_MINIMUM - 28)) | (1 << (TDantlrParser.K_SUBSTR - 28)) | (1 << (TDantlrParser.K_ADD_MONTHS - 28)) | (1 << (TDantlrParser.K_SUBSTRING - 28)) | (1 << (TDantlrParser.K_SUM - 28)) | (1 << (TDantlrParser.K_REGR_AVGX - 28)))) != 0) or ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & ((1 << (TDantlrParser.K_REGR_AVGY - 95)) | (1 << (TDantlrParser.K_MOD - 95)) | (1 << (TDantlrParser.K_REGR_COUNT - 95)) | (1 << (TDantlrParser.K_CURRENT_DATE - 95)) | (1 << (TDantlrParser.K_REGR_INTERCEPT - 95)) | (1 << (TDantlrParser.K_TAN - 95)) | (1 << (TDantlrParser.K_CURRENT_TIME - 95)) | (1 << (TDantlrParser.K_REGR_R2 - 95)) | (1 << (TDantlrParser.K_TANH - 95)) | (1 << (TDantlrParser.K_CURRENT_TIMESTAMP - 95)) | (1 << (TDantlrParser.K_REGR_SLOPE - 95)) | (1 << (TDantlrParser.K_REGR_SXX - 95)) | (1 << (TDantlrParser.K_REGR_SXY - 95)) | (1 << (TDantlrParser.K_REGR_SYY - 95)) | (1 << (TDantlrParser.K_DATABASE - 95)) | (1 << (TDantlrParser.K_TIME - 95)) | (1 << (TDantlrParser.K_ASIN - 95)) | (1 << (TDantlrParser.K_DATE - 95)) | (1 << (TDantlrParser.K_ASINH - 95)))) != 0) or ((((_la - 169)) & ~0x3f) == 0 and ((1 << (_la - 169)) & ((1 << (TDantlrParser.K_ATAN - 169)) | (1 << (TDantlrParser.K_TITLE - 169)) | (1 << (TDantlrParser.K_ATAN2 - 169)) | (1 << (TDantlrParser.K_ATANH - 169)) | (1 << (TDantlrParser.K_DEFAULT - 169)) | (1 << (TDantlrParser.K_DEGREES - 169)) | (1 << (TDantlrParser.K_INDEX - 169)) | (1 << (TDantlrParser.K_TRANSLATE - 169)) | (1 << (TDantlrParser.K_TRANSLATE_CHK - 169)) | (1 << (TDantlrParser.K_AVG - 169)) | (1 << (TDantlrParser.K_TRIM - 169)) | (1 << (TDantlrParser.K_NULLIF - 169)) | (1 << (TDantlrParser.K_TYPE - 169)) | (1 << (TDantlrParser.K_NULLIFZERO - 169)))) != 0) or ((((_la - 233)) & ~0x3f) == 0 and ((1 << (_la - 233)) & ((1 << (TDantlrParser.K_RIGHT - 233)) | (1 << (TDantlrParser.K_ROLE - 233)) | (1 << (TDantlrParser.K_OCTET_LENGTH - 233)) | (1 << (TDantlrParser.K_BYTE - 233)) | (1 << (TDantlrParser.K_INTERVAL - 233)) | (1 << (TDantlrParser.K_BYTES - 233)) | (1 << (TDantlrParser.K_ROW_NUMBER - 233)) | (1 << (TDantlrParser.K_UPPER - 233)) | (1 << (TDantlrParser.K_USER - 233)))) != 0) or ((((_la - 301)) & ~0x3f) == 0 and ((1 << (_la - 301)) & ((1 << (TDantlrParser.K_CASE_N - 301)) | (1 << (TDantlrParser.K_CAST - 301)) | (1 << (TDantlrParser.K_KURTOSIS - 301)) | (1 << (TDantlrParser.K_CHAR - 301)) | (1 << (TDantlrParser.K_SESSION - 301)) | (1 << (TDantlrParser.K_CHAR2HEXINT - 301)) | (1 << (TDantlrParser.K_VARGRAPHIC - 301)) | (1 << (TDantlrParser.K_CHARACTERS - 301)) | (1 << (TDantlrParser.K_VAR_POP - 301)) | (1 << (TDantlrParser.K_CHARACTER_LENGTH - 301)) | (1 << (TDantlrParser.K_LEFT - 301)) | (1 << (TDantlrParser.K_VAR_SAMP - 301)) | (1 << (TDantlrParser.K_CHARS - 301)) | (1 << (TDantlrParser.K_CHAR_LENGTH - 301)) | (1 << (TDantlrParser.K_SIN - 301)) | (1 << (TDantlrParser.K_LN - 301)) | (1 << (TDantlrParser.K_PERCENT_RANK - 301)))) != 0) or ((((_la - 365)) & ~0x3f) == 0 and ((1 << (_la - 365)) & ((1 << (TDantlrParser.K_SINH - 365)) | (1 << (TDantlrParser.K_SKEW - 365)) | (1 << (TDantlrParser.K_EXP - 365)) | (1 << (TDantlrParser.K_POSITION - 365)) | (1 << (TDantlrParser.K_SOUNDEX - 365)) | (1 << (TDantlrParser.K_WIDTH_BUCKET - 365)) | (1 << (TDantlrParser.K_COALESCE - 365)) | (1 << (TDantlrParser.K_EXTRACT - 365)) | (1 << (TDantlrParser.K_LOG - 365)) | (1 << (TDantlrParser.K_ZEROIFNULL - 365)))) != 0) or ((((_la - 429)) & ~0x3f) == 0 and ((1 << (_la - 429)) & ((1 << (TDantlrParser.K_LOWER - 429)) | (1 << (TDantlrParser.K_PROFILE - 429)) | (1 << (TDantlrParser.K_SQRT - 429)) | (1 << (TDantlrParser.K_FORMAT - 429)) | (1 << (TDantlrParser.K_LTRIM - 429)) | (1 << (TDantlrParser.K_RTRIM - 429)) | (1 << (TDantlrParser.K_LPAD - 429)) | (1 << (TDantlrParser.K_RPAD - 429)) | (1 << (TDantlrParser.K_CUME_DIST - 429)) | (1 << (TDantlrParser.K_DENSE_RANK - 429)) | (1 << (TDantlrParser.K_FIRST_VALUE - 429)) | (1 << (TDantlrParser.K_LAST_VALUE - 429)) | (1 << (TDantlrParser.K_CEILING - 429)) | (1 << (TDantlrParser.K_FLOOR - 429)) | (1 << (TDantlrParser.K_POWER - 429)) | (1 << (TDantlrParser.K_ROUND - 429)) | (1 << (TDantlrParser.K_SIGN - 429)) | (1 << (TDantlrParser.K_TRUNC - 429)) | (1 << (TDantlrParser.K_DEGREESRADIANS - 429)) | (1 << (TDantlrParser.K_NVL - 429)) | (1 << (TDantlrParser.K_NVL2 - 429)) | (1 << (TDantlrParser.K_ASCII - 429)) | (1 << (TDantlrParser.K_CHR - 429)) | (1 << (TDantlrParser.K_CSVLD - 429)) | (1 << (TDantlrParser.K_EDITDISTANCE - 429)) | (1 << (TDantlrParser.K_INITCAP - 429)) | (1 << (TDantlrParser.K_INSTR - 429)) | (1 << (TDantlrParser.K_NGRAM - 429)) | (1 << (TDantlrParser.K_NVP - 429)) | (1 << (TDantlrParser.K_OREPLACE - 429)) | (1 << (TDantlrParser.K_OTRANSLATE - 429)) | (1 << (TDantlrParser.K_STRTOK - 429)))) != 0) or ((((_la - 493)) & ~0x3f) == 0 and ((1 << (_la - 493)) & ((1 << (TDantlrParser.K_STRTOK_SPLIT_TO_TABLE - 493)) | (1 << (TDantlrParser.K_LENGTH - 493)) | (1 << (TDantlrParser.K_CSV - 493)) | (1 << (TDantlrParser.K_CURRENT_ROLE - 493)) | (1 << (TDantlrParser.K_CURRENT_USER - 493)) | (1 << (TDantlrParser.K_TEMPORAL_DATE - 493)) | (1 << (TDantlrParser.K_TEMPORAL_TIMESTAMP - 493)) | (1 << (TDantlrParser.K_BITAND - 493)) | (1 << (TDantlrParser.K_BITNOT - 493)) | (1 << (TDantlrParser.K_BITOR - 493)) | (1 << (TDantlrParser.K_BITXOR - 493)) | (1 << (TDantlrParser.K_COUNTSET - 493)) | (1 << (TDantlrParser.K_GETBIT - 493)) | (1 << (TDantlrParser.K_ROTATELEFT - 493)) | (1 << (TDantlrParser.K_ROTATERIGHT - 493)) | (1 << (TDantlrParser.K_SETBIT - 493)) | (1 << (TDantlrParser.K_SHIFTLEFT - 493)) | (1 << (TDantlrParser.K_SHIFTRIGHT - 493)) | (1 << (TDantlrParser.K_SUBBITSTR - 493)) | (1 << (TDantlrParser.K_TO_BYTE - 493)) | (1 << (TDantlrParser.K_TO_CHAR - 493)) | (1 << (TDantlrParser.K_TO_DATE - 493)) | (1 << (TDantlrParser.K_TO_TIMESTAMP - 493)) | (1 << (TDantlrParser.K_TO_NUMBER - 493)) | (1 << (TDantlrParser.K_OADD_MONTHS - 493)) | (1 << (TDantlrParser.K_GROUPING - 493)) | (1 << (TDantlrParser.K_CEIL - 493)) | (1 << (TDantlrParser.K_GREATEST - 493)) | (1 << (TDantlrParser.K_LEAST - 493)) | (1 << (TDantlrParser.K_LAST_DAY - 493)) | (1 << (TDantlrParser.K_NEXT_DAY - 493)) | (1 << (TDantlrParser.K_MONTHS_BETWEEN - 493)) | (1 << (TDantlrParser.K_REVERSE - 493)) | (1 << (TDantlrParser.K_TD_DAY_OF_WEEK - 493)) | (1 << (TDantlrParser.K_TD_DAY_OF_MONTH - 493)) | (1 << (TDantlrParser.K_TD_DAY_OF_YEAR - 493)) | (1 << (TDantlrParser.K_TD_WEEK_OF_YEAR - 493)) | (1 << (TDantlrParser.K_TD_MONTH_OF_QUARTER - 493)) | (1 << (TDantlrParser.K_TD_MONTH_OF_YEAR - 493)) | (1 << (TDantlrParser.K_TD_QUARTER_OF_YEAR - 493)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Analytical_function_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CSUM(self):
            return self.getToken(TDantlrParser.K_CSUM, 0)

        def K_CUME_DIST(self):
            return self.getToken(TDantlrParser.K_CUME_DIST, 0)

        def K_DENSE_RANK(self):
            return self.getToken(TDantlrParser.K_DENSE_RANK, 0)

        def K_FIRST_VALUE(self):
            return self.getToken(TDantlrParser.K_FIRST_VALUE, 0)

        def K_LAST_VALUE(self):
            return self.getToken(TDantlrParser.K_LAST_VALUE, 0)

        def K_MAVG(self):
            return self.getToken(TDantlrParser.K_MAVG, 0)

        def K_MDIFF(self):
            return self.getToken(TDantlrParser.K_MDIFF, 0)

        def K_MEDIAN(self):
            return self.getToken(TDantlrParser.K_MEDIAN, 0)

        def K_MLINREG(self):
            return self.getToken(TDantlrParser.K_MLINREG, 0)

        def K_MSUM(self):
            return self.getToken(TDantlrParser.K_MSUM, 0)

        def K_PERCENT_RANK(self):
            return self.getToken(TDantlrParser.K_PERCENT_RANK, 0)

        def K_PERCENTILE_CON(self):
            return self.getToken(TDantlrParser.K_PERCENTILE_CON, 0)

        def K_PERCENTILE_DIS(self):
            return self.getToken(TDantlrParser.K_PERCENTILE_DIS, 0)

        def K_QUANTILE(self):
            return self.getToken(TDantlrParser.K_QUANTILE, 0)

        def K_RANK(self):
            return self.getToken(TDantlrParser.K_RANK, 0)

        def K_ROW_NUMBER(self):
            return self.getToken(TDantlrParser.K_ROW_NUMBER, 0)

        def K_AVG(self):
            return self.getToken(TDantlrParser.K_AVG, 0)

        def K_MIN(self):
            return self.getToken(TDantlrParser.K_MIN, 0)

        def K_MAX(self):
            return self.getToken(TDantlrParser.K_MAX, 0)

        def K_SUM(self):
            return self.getToken(TDantlrParser.K_SUM, 0)

        def K_COUNT(self):
            return self.getToken(TDantlrParser.K_COUNT, 0)

        def K_CORR(self):
            return self.getToken(TDantlrParser.K_CORR, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_analytical_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnalytical_function_name" ):
                listener.enterAnalytical_function_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnalytical_function_name" ):
                listener.exitAnalytical_function_name(self)




    def analytical_function_name(self):

        localctx = TDantlrParser.Analytical_function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_analytical_function_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1014
            _la = self._input.LA(1)
            if not(((((_la - 28)) & ~0x3f) == 0 and ((1 << (_la - 28)) & ((1 << (TDantlrParser.K_MAX - 28)) | (1 << (TDantlrParser.K_CORR - 28)) | (1 << (TDantlrParser.K_QUANTILE - 28)) | (1 << (TDantlrParser.K_MDIFF - 28)) | (1 << (TDantlrParser.K_COUNT - 28)) | (1 << (TDantlrParser.K_MIN - 28)) | (1 << (TDantlrParser.K_RANK - 28)) | (1 << (TDantlrParser.K_SUM - 28)) | (1 << (TDantlrParser.K_CSUM - 28)) | (1 << (TDantlrParser.K_MLINREG - 28)))) != 0) or _la==TDantlrParser.K_MSUM or _la==TDantlrParser.K_AVG or _la==TDantlrParser.K_ROW_NUMBER or _la==TDantlrParser.K_PERCENT_RANK or ((((_la - 444)) & ~0x3f) == 0 and ((1 << (_la - 444)) & ((1 << (TDantlrParser.K_MAVG - 444)) | (1 << (TDantlrParser.K_CUME_DIST - 444)) | (1 << (TDantlrParser.K_DENSE_RANK - 444)) | (1 << (TDantlrParser.K_FIRST_VALUE - 444)) | (1 << (TDantlrParser.K_LAST_VALUE - 444)) | (1 << (TDantlrParser.K_MEDIAN - 444)) | (1 << (TDantlrParser.K_PERCENTILE_CON - 444)) | (1 << (TDantlrParser.K_PERCENTILE_DIS - 444)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Custom_function_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(TDantlrParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return TDantlrParser.RULE_custom_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCustom_function_name" ):
                listener.enterCustom_function_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCustom_function_name" ):
                listener.exitCustom_function_name(self)




    def custom_function_name(self):

        localctx = TDantlrParser.Custom_function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_custom_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1016
            self.match(TDantlrParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[4] = self.select_expr_sempred
        self._predicates[12] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def select_expr_sempred(self, localctx:Select_exprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 1)
         




